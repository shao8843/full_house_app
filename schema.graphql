# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

union Morph = AboutFastBraiin | Account | AccountAggregator | AccountConnection | AccountConnectionCreated_at | AccountConnectionId | AccountConnectionName | AccountConnectionUpdated_at | AccountConnectionUser | AccountGroupBy | AppTermOfService | Article | ArticleAggregator | ArticleConnection | ArticleConnectionContent | ArticleConnectionCreated_at | ArticleConnectionForPerson | ArticleConnectionId | ArticleConnectionName | ArticleConnectionPost | ArticleConnectionPublished_at | ArticleConnectionQuestionnaire | ArticleConnectionSubject | ArticleConnectionUpdated_at | ArticleGroupBy | AssessmentQuestionnaire | AssessmentQuestionnaireAggregator | AssessmentQuestionnaireAggregatorAvg | AssessmentQuestionnaireAggregatorMax | AssessmentQuestionnaireAggregatorMin | AssessmentQuestionnaireAggregatorSum | AssessmentQuestionnaireConnection | AssessmentQuestionnaireConnectionContent | AssessmentQuestionnaireConnectionCreated_at | AssessmentQuestionnaireConnectionForPerson | AssessmentQuestionnaireConnectionGame | AssessmentQuestionnaireConnectionId | AssessmentQuestionnaireConnectionLevel | AssessmentQuestionnaireConnectionName | AssessmentQuestionnaireConnectionPeriod_length | AssessmentQuestionnaireConnectionPost | AssessmentQuestionnaireConnectionProduct | AssessmentQuestionnaireConnectionQuestionnaire | AssessmentQuestionnaireConnectionQuestionnaireOnly | AssessmentQuestionnaireConnectionSubject | AssessmentQuestionnaireConnectionUpdated_at | AssessmentQuestionnaireGroupBy | AssessmentTermOfService | Book | BookAggregator | BookConnection | BookConnectionContent | BookConnectionCreated_at | BookConnectionId | BookConnectionName | BookConnectionPost | BookConnectionProduct | BookConnectionType | BookConnectionUpdated_at | BookGroupBy | Category | CategoryAggregator | CategoryConnection | CategoryConnectionCreated_at | CategoryConnectionId | CategoryConnectionName | CategoryConnectionType | CategoryConnectionUpdated_at | CategoryGroupBy | Classification | ClassificationAggregator | ClassificationAggregatorAvg | ClassificationAggregatorMax | ClassificationAggregatorMin | ClassificationAggregatorSum | ClassificationConnection | ClassificationConnectionCreated_at | ClassificationConnectionId | ClassificationConnectionName | ClassificationConnectionPublished_at | ClassificationConnectionSortIndex | ClassificationConnectionUpdated_at | ClassificationGroupBy | Color | ColorAggregator | ColorConnection | ColorConnectionColor | ColorConnectionCreated_at | ColorConnectionId | ColorConnectionUpdated_at | ColorGroupBy | ComponentContentEpisode | ComponentContentEventComponent | ComponentContentEventPrice | ComponentContentPost | ComponentContentProduct | ComponentContentSummary | ComponentDataAddress | ComponentDataEhrSubject | ComponentDataEhrType | ComponentDataFor | ComponentDataPosition | ComponentUserAuthor | ComponentUserChild | ComponentUserCounselor | ComponentUserDoctor | ComponentUserNurse | ComponentUserParent | ComponentUserPatient | ComponentUserTeacher | Course | CourseAggregator | CourseConnection | CourseConnectionContent | CourseConnectionContentType | CourseConnectionCreated_at | CourseConnectionId | CourseConnectionPicture | CourseConnectionSubtitle | CourseConnectionTitle | CourseConnectionUpdated_at | CourseGroupBy | CreditCard | CreditCardAggregator | CreditCardAggregatorAvg | CreditCardAggregatorMax | CreditCardAggregatorMin | CreditCardAggregatorSum | CreditCardConnection | CreditCardConnectionAddress | CreditCardConnectionCreated_at | CreditCardConnectionCvc | CreditCardConnectionExpMonth | CreditCardConnectionExpYear | CreditCardConnectionId | CreditCardConnectionName | CreditCardConnectionNumber | CreditCardConnectionUpdated_at | CreditCardConnectionUser | CreditCardGroupBy | Ehr | EhrAggregator | EhrConnection | EhrConnectionClassification | EhrConnectionCreated_at | EhrConnectionId | EhrConnectionOffice_comments | EhrConnectionPatient | EhrConnectionPosition | EhrConnectionQuestionnaire_answer | EhrConnectionRecord | EhrConnectionSource | EhrConnectionSource_id | EhrConnectionStatus | EhrConnectionSubject | EhrConnectionUpdated_at | EhrGroupBy | Event | EventAggregator | EventAggregatorAvg | EventAggregatorMax | EventAggregatorMin | EventAggregatorSum | EventConnection | EventConnectionContent | EventConnectionCreated_at | EventConnectionDicount | EventConnectionEventComponent | EventConnectionId | EventConnectionName | EventConnectionPost | EventConnectionUpdated_at | EventGroupBy | Exercise | ExerciseAggregator | ExerciseAggregatorAvg | ExerciseAggregatorMax | ExerciseAggregatorMin | ExerciseAggregatorSum | ExerciseConnection | ExerciseConnectionAge | ExerciseConnectionContent | ExerciseConnectionCreated_at | ExerciseConnectionForPerson | ExerciseConnectionGame | ExerciseConnectionId | ExerciseConnectionLevel | ExerciseConnectionPost | ExerciseConnectionQuestionnaire | ExerciseConnectionSubject | ExerciseConnectionType | ExerciseConnectionUpdated_at | ExerciseGroupBy | FlowchartTest | Game | GameAggregator | GameAggregatorAvg | GameAggregatorMax | GameAggregatorMin | GameAggregatorSum | GameConnection | GameConnectionContent | GameConnectionCptLevel | GameConnectionCreated_at | GameConnectionId | GameConnectionName | GameConnectionProvider | GameConnectionTrademark | GameConnectionType | GameConnectionUpdated_at | GameGroupBy | Location | LocationAggregator | LocationConnection | LocationConnectionAddress | LocationConnectionContent | LocationConnectionCreated_at | LocationConnectionDescription | LocationConnectionEmail | LocationConnectionId | LocationConnectionName | LocationConnectionPhone | LocationConnectionPost | LocationConnectionQrCode | LocationConnectionType | LocationConnectionUpdated_at | LocationConnectionWeb | LocationGroupBy | Parenting | ParentingAggregator | ParentingConnection | ParentingConnectionContent | ParentingConnectionCreated_at | ParentingConnectionId | ParentingConnectionName | ParentingConnectionPdfFiles | ParentingConnectionPost | ParentingConnectionQuestionnaire | ParentingConnectionSubject | ParentingConnectionUpdated_at | ParentingGroupBy | Patient | PatientAggregator | PatientConnection | PatientConnectionCounselor | PatientConnectionCreated_at | PatientConnectionDoctor | PatientConnectionId | PatientConnectionLocation | PatientConnectionMeetingId | PatientConnectionName | PatientConnectionNurse | PatientConnectionStatus | PatientConnectionTeacher | PatientConnectionUpdated_at | PatientConnectionUser | PatientGroupBy | PaymentCurrency | PaymentCurrencyAggregator | PaymentCurrencyAggregatorAvg | PaymentCurrencyAggregatorMax | PaymentCurrencyAggregatorMin | PaymentCurrencyAggregatorSum | PaymentCurrencyConnection | PaymentCurrencyConnectionCode | PaymentCurrencyConnectionCreated_at | PaymentCurrencyConnectionDecimal_digits | PaymentCurrencyConnectionId | PaymentCurrencyConnectionName | PaymentCurrencyConnectionName_plural | PaymentCurrencyConnectionRounding | PaymentCurrencyConnectionSymbol | PaymentCurrencyConnectionSymbol_native | PaymentCurrencyConnectionUpdated_at | PaymentCurrencyGroupBy | PaymentMethod | PaymentMethodAggregator | PaymentMethodConnection | PaymentMethodConnectionBillingAddress | PaymentMethodConnectionCreated_at | PaymentMethodConnectionCreditCard | PaymentMethodConnectionId | PaymentMethodConnectionLivemode | PaymentMethodConnectionStripeId | PaymentMethodConnectionType | PaymentMethodConnectionUpdated_at | PaymentMethodConnectionUser | PaymentMethodGroupBy | PaymentOrder | PaymentOrderAggregator | PaymentOrderAggregatorAvg | PaymentOrderAggregatorMax | PaymentOrderAggregatorMin | PaymentOrderAggregatorSum | PaymentOrderConnection | PaymentOrderConnectionAdditional | PaymentOrderConnectionCreated_at | PaymentOrderConnectionCurrency | PaymentOrderConnectionDescription | PaymentOrderConnectionExpire | PaymentOrderConnectionId | PaymentOrderConnectionNeedpayPrice | PaymentOrderConnectionOutTradeId | PaymentOrderConnectionOutTradeProvider | PaymentOrderConnectionPaiedPrice | PaymentOrderConnectionPrice | PaymentOrderConnectionShippingAddress | PaymentOrderConnectionStatus | PaymentOrderConnectionUpdated_at | PaymentOrderConnectionUser | PaymentOrderConnectionUuid | PaymentOrderGroupBy | PaymentOrderItem | PaymentPolicy | PaymentSetting | Plan | PlanAggregator | PlanConnection | PlanConnectionContent | PlanConnectionCreated_at | PlanConnectionForPerson | PlanConnectionId | PlanConnectionName | PlanConnectionPost | PlanConnectionQuestionnaire | PlanConnectionUpdated_at | PlanGroupBy | Post | PostAggregator | PostAggregatorAvg | PostAggregatorMax | PostAggregatorMin | PostAggregatorSum | PostConnection | PostConnectionAuthor | PostConnectionCover_background_color | PostConnectionCreated_at | PostConnectionCurrency | PostConnectionEntityRawId | PostConnectionEntityType | PostConnectionId | PostConnectionNeedShipping | PostConnectionPrePrice | PostConnectionPrice | PostConnectionPublished_at | PostConnectionRating | PostConnectionRawPostId | PostConnectionRecommended | PostConnectionStatus | PostConnectionSubtitle | PostConnectionTitle | PostConnectionTrademark | PostConnectionUpdated_at | PostConnectionUpdated_day | PostConnectionVipText | PostConnectionVip_color | PostGroupBy | Provider | ProviderAggregator | ProviderConnection | ProviderConnectionAddress | ProviderConnectionContent | ProviderConnectionCreated_at | ProviderConnectionEmail | ProviderConnectionId | ProviderConnectionName | ProviderConnectionPhoneNumber | ProviderConnectionTrademark | ProviderConnectionUpdated_at | ProviderGroupBy | Questionnaire | QuestionnaireAggregator | QuestionnaireAnswer | QuestionnaireAnswerAggregator | QuestionnaireAnswerConnection | QuestionnaireAnswerConnectionCreated_at | QuestionnaireAnswerConnectionData | QuestionnaireAnswerConnectionId | QuestionnaireAnswerConnectionName | QuestionnaireAnswerConnectionQuestionnaire | QuestionnaireAnswerConnectionSubmitted | QuestionnaireAnswerConnectionUpdated_at | QuestionnaireAnswerConnectionUser | QuestionnaireAnswerGroupBy | QuestionnaireConnection | QuestionnaireConnectionCreated_at | QuestionnaireConnectionData | QuestionnaireConnectionDisplayName | QuestionnaireConnectionId | QuestionnaireConnectionName | QuestionnaireConnectionProvider | QuestionnaireConnectionUpdated_at | QuestionnaireGroupBy | Reminder | ReminderAggregator | ReminderConnection | ReminderConnectionBody | ReminderConnectionCreated_at | ReminderConnectionDateTime | ReminderConnectionId | ReminderConnectionName | ReminderConnectionSource | ReminderConnectionSourceId | ReminderConnectionType | ReminderConnectionUpdated_at | ReminderConnectionUser | ReminderGroupBy | School | SchoolAggregator | SchoolConnection | SchoolConnectionAddress | SchoolConnectionCreated_at | SchoolConnectionEmail | SchoolConnectionId | SchoolConnectionName | SchoolConnectionPhone | SchoolConnectionPicture | SchoolConnectionType | SchoolConnectionUpdated_at | SchoolGroupBy | Supplement | SupplementAggregator | SupplementConnection | SupplementConnectionContent | SupplementConnectionCreated_at | SupplementConnectionForPerson | SupplementConnectionId | SupplementConnectionName | SupplementConnectionPost | SupplementConnectionProduct | SupplementConnectionSubject | SupplementConnectionUpdated_at | SupplementGroupBy | Telemetry | TelemetryAggregator | TelemetryConnection | TelemetryConnectionCreated_at | TelemetryConnectionId | TelemetryConnectionRaw | TelemetryConnectionUpdated_at | TelemetryGroupBy | Trademark | TrademarkAggregator | TrademarkConnection | TrademarkConnectionCreated_at | TrademarkConnectionId | TrademarkConnectionImage | TrademarkConnectionName | TrademarkConnectionUpdated_at | TrademarkGroupBy | UploadFile | UploadFileAggregator | UploadFileAggregatorAvg | UploadFileAggregatorMax | UploadFileAggregatorMin | UploadFileAggregatorSum | UploadFileConnection | UploadFileConnectionAlternativeText | UploadFileConnectionCaption | UploadFileConnectionCreated_at | UploadFileConnectionExt | UploadFileConnectionFormats | UploadFileConnectionHash | UploadFileConnectionHeight | UploadFileConnectionId | UploadFileConnectionMime | UploadFileConnectionName | UploadFileConnectionPreviewUrl | UploadFileConnectionProvider | UploadFileConnectionProvider_metadata | UploadFileConnectionSize | UploadFileConnectionUpdated_at | UploadFileConnectionUrl | UploadFileConnectionWidth | UploadFileGroupBy | UserAddress | UserAddressAggregator | UserAddressConnection | UserAddressConnectionAddress | UserAddressConnectionCreated_at | UserAddressConnectionId | UserAddressConnectionTag | UserAddressConnectionUpdated_at | UserAddressConnectionUser | UserAddressGroupBy | UserAgreement | UserAgreementAggregator | UserAgreementConnection | UserAgreementConnectionContent | UserAgreementConnectionCreated_at | UserAgreementConnectionId | UserAgreementConnectionLastVersionDate | UserAgreementConnectionTermOfServiceType | UserAgreementConnectionUpdated_at | UserAgreementConnectionUser | UserAgreementConnectionValue | UserAgreementGroupBy | UserAssessment | UserAssessmentAggregator | UserAssessmentConnection | UserAssessmentConnectionAssessment_questionnaire | UserAssessmentConnectionCreated_at | UserAssessmentConnectionId | UserAssessmentConnectionUpdated_at | UserAssessmentConnectionUser | UserAssessmentGroupBy | UserExercise | UserExerciseAggregator | UserExerciseConnection | UserExerciseConnectionCreated_at | UserExerciseConnectionExercise | UserExerciseConnectionId | UserExerciseConnectionUpdated_at | UserExerciseConnectionUser | UserExerciseGroupBy | UserParenting | UserParentingAggregator | UserParentingConnection | UserParentingConnectionCreated_at | UserParentingConnectionId | UserParentingConnectionParenting | UserParentingConnectionUpdated_at | UserParentingConnectionUser | UserParentingGroupBy | UserPermissionsPasswordPayload | UserPlan | UserPlanAggregator | UserPlanConnection | UserPlanConnectionCreated_at | UserPlanConnectionId | UserPlanConnectionStatus | UserPlanConnectionUpdated_at | UserPlanConnectionUser | UserPlanGroupBy | UsersOrganizationunitsOrganizationUnit | UsersOrganizationunitsOrganizationUnitAggregator | UsersOrganizationunitsOrganizationUnitConnection | UsersOrganizationunitsOrganizationUnitConnectionCode | UsersOrganizationunitsOrganizationUnitConnectionCreated_at | UsersOrganizationunitsOrganizationUnitConnectionDisplayName | UsersOrganizationunitsOrganizationUnitConnectionId | UsersOrganizationunitsOrganizationUnitConnectionParent | UsersOrganizationunitsOrganizationUnitConnectionUpdated_at | UsersOrganizationunitsOrganizationUnitGroupBy | UsersPermissionsLoginPayload | UsersPermissionsMe | UsersPermissionsMeRole | UsersPermissionsPermission | UsersPermissionsRefreshTokenPayload | UsersPermissionsRole | UsersPermissionsRoleAggregator | UsersPermissionsRoleConnection | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionId | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionType | UsersPermissionsRoleGroupBy | UsersPermissionsUser | UsersPermissionsUserAggregator | UsersPermissionsUserConnection | UsersPermissionsUserConnectionAccountInfo | UsersPermissionsUserConnectionAuthorInfo | UsersPermissionsUserConnectionBirthday | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionChildInfo | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionContent | UsersPermissionsUserConnectionCounselorInfo | UsersPermissionsUserConnectionCreated_at | UsersPermissionsUserConnectionDoctorInfo | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionFullName | UsersPermissionsUserConnectionId | UsersPermissionsUserConnectionImage | UsersPermissionsUserConnectionName | UsersPermissionsUserConnectionNurseInfo | UsersPermissionsUserConnectionParent | UsersPermissionsUserConnectionParentInfo | UsersPermissionsUserConnectionPatientInfo | UsersPermissionsUserConnectionPhone | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionQrUrl | UsersPermissionsUserConnectionRole | UsersPermissionsUserConnectionSecond_email | UsersPermissionsUserConnectionSex | UsersPermissionsUserConnectionStatus | UsersPermissionsUserConnectionTeacherInfo | UsersPermissionsUserConnectionUpdated_at | UsersPermissionsUserConnectionUsername | UsersPermissionsUserGroupBy | Venue | VenueAggregator | VenueAggregatorAvg | VenueAggregatorMax | VenueAggregatorMin | VenueAggregatorSum | VenueConnection | VenueConnectionAddress | VenueConnectionCapacity | VenueConnectionContacts | VenueConnectionContent | VenueConnectionCreated_at | VenueConnectionEmail | VenueConnectionId | VenueConnectionName | VenueConnectionPhoneNumber | VenueConnectionPicture | VenueConnectionPost | VenueConnectionUpdated_at | VenueGroupBy | Version | Webinar | WebinarAggregator | WebinarConnection | WebinarConnectionContent | WebinarConnectionCreated_at | WebinarConnectionId | WebinarConnectionMeetingId | WebinarConnectionPost | WebinarConnectionSchedule | WebinarConnectionSubject | WebinarConnectionUpdated_at | WebinarGroupBy | batchTelemetryPayload | cancelOrderPayload | createAccountPayload | createArticlePayload | createAssessmentQuestionnairePayload | createBookPayload | createCategoryPayload | createClassificationPayload | createColorPayload | createCoursePayload | createCreditCardPayload | createCurrencyPayload | createEhrPayload | createEventPayload | createExercisePayload | createGamePayload | createLocationPayload | createOrderPayload | createOrganizationUnitPayload | createParentingPayload | createPatientPayload | createPaymentMethodPayload | createPlanPayload | createPostPayload | createProviderPayload | createQuestionnaireAnswerPayload | createQuestionnairePayload | createReminderPayload | createRolePayload | createSchoolPayload | createSupplementPayload | createTelemetryPayload | createTrademarkPayload | createUserAddressPayload | createUserAgreementPayload | createUserAssessmentPayload | createUserExercisePayload | createUserParentingPayload | createUserPayload | createUserPlanPayload | createVenuePayload | createWebinarPayload | deleteAboutFastBraiinPayload | deleteAccountPayload | deleteAppTermOfServicePayload | deleteArticlePayload | deleteAssessmentQuestionnairePayload | deleteAssessmentTermOfServicePayload | deleteBookPayload | deleteCategoryPayload | deleteClassificationPayload | deleteColorPayload | deleteCoursePayload | deleteCreditCardPayload | deleteCurrencyPayload | deleteEhrPayload | deleteEventPayload | deleteExercisePayload | deleteFilePayload | deleteGamePayload | deleteLocationPayload | deleteOrderPayload | deleteOrganizationUnitPayload | deleteParentingPayload | deletePatientPayload | deletePaymentMethodPayload | deletePaymentPolicyPayload | deletePlanPayload | deletePostPayload | deleteProviderPayload | deleteQuestionnaireAnswerPayload | deleteQuestionnairePayload | deleteReminderPayload | deleteRolePayload | deleteSchoolPayload | deleteSupplementPayload | deleteTelemetryPayload | deleteTrademarkPayload | deleteUserAddressPayload | deleteUserAgreementPayload | deleteUserAssessmentPayload | deleteUserExercisePayload | deleteUserParentingPayload | deleteUserPayload | deleteUserPlanPayload | deleteVenuePayload | deleteVersionPayload | deleteWebinarPayload | requestOrderPayPayload | updateAboutFastBraiinPayload | updateAccountPayload | updateAppTermOfServicePayload | updateArticlePayload | updateAssessmentQuestionnairePayload | updateAssessmentTermOfServicePayload | updateBookPayload | updateCategoryPayload | updateClassificationPayload | updateColorPayload | updateCoursePayload | updateCreditCardPayload | updateCurrencyPayload | updateEhrPayload | updateEventPayload | updateExercisePayload | updateGamePayload | updateLocationPayload | updateOrderPayload | updateOrganizationUnitPayload | updateParentingPayload | updatePatientPayload | updatePaymentMethodPayload | updatePaymentPolicyPayload | updatePlanPayload | updatePostPayload | updateProviderPayload | updateQuestionnaireAnswerPayload | updateQuestionnairePayload | updateReminderPayload | updateRolePayload | updateSchoolPayload | updateSupplementPayload | updateTelemetryPayload | updateTrademarkPayload | updateUserAddressPayload | updateUserAgreementPayload | updateUserAssessmentPayload | updateUserExercisePayload | updateUserParentingPayload | updateUserPayload | updateUserPlanPayload | updateVenuePayload | updateVersionPayload | updateWebinarPayload

type AboutFastBraiin {
    content: String!
    created_at: DateTime!
    id: ID!
    updated_at: DateTime!
}

type Account {
    created_at: DateTime!
    id: ID!
    name: String!
    orders(limit: Int, sort: String, start: Int, where: JSON): [PaymentOrder]
    updated_at: DateTime!
    user: UsersPermissionsUser
}

type AccountAggregator {
    count: Int
    totalCount: Int
}

type AccountConnection {
    aggregate: AccountAggregator
    groupBy: AccountGroupBy
    values: [Account]
}

type AccountConnectionCreated_at {
    connection: AccountConnection
    key: DateTime
}

type AccountConnectionId {
    connection: AccountConnection
    key: ID
}

type AccountConnectionName {
    connection: AccountConnection
    key: String
}

type AccountConnectionUpdated_at {
    connection: AccountConnection
    key: DateTime
}

type AccountConnectionUser {
    connection: AccountConnection
    key: ID
}

type AccountGroupBy {
    created_at: [AccountConnectionCreated_at]
    id: [AccountConnectionId]
    name: [AccountConnectionName]
    updated_at: [AccountConnectionUpdated_at]
    user: [AccountConnectionUser]
}

type AdminUser {
    firstname: String!
    id: ID!
    lastname: String!
    username: String
}

type AppTermOfService {
    created_at: DateTime!
    id: ID!
    term_of_service: String
    updated_at: DateTime!
}

type Article {
    content: String!
    created_at: DateTime!
    episodes: [ComponentContentEpisode]
    forPerson: ComponentDataFor
    id: ID!
    media(limit: Int, sort: String, start: Int, where: JSON): [UploadFile]
    name: String!
    order_items(limit: Int, sort: String, start: Int, where: JSON): [PaymentOrderItem]
    post: ComponentContentPost
    published_at: DateTime
    questionnaire: Questionnaire
    subject: ComponentDataEhrSubject
    updated_at: DateTime!
}

type ArticleAggregator {
    count: Int
    totalCount: Int
}

type ArticleConnection {
    aggregate: ArticleAggregator
    groupBy: ArticleGroupBy
    values: [Article]
}

type ArticleConnectionContent {
    connection: ArticleConnection
    key: String
}

type ArticleConnectionCreated_at {
    connection: ArticleConnection
    key: DateTime
}

type ArticleConnectionForPerson {
    connection: ArticleConnection
    key: ID
}

type ArticleConnectionId {
    connection: ArticleConnection
    key: ID
}

type ArticleConnectionName {
    connection: ArticleConnection
    key: String
}

type ArticleConnectionPost {
    connection: ArticleConnection
    key: ID
}

type ArticleConnectionPublished_at {
    connection: ArticleConnection
    key: DateTime
}

type ArticleConnectionQuestionnaire {
    connection: ArticleConnection
    key: ID
}

type ArticleConnectionSubject {
    connection: ArticleConnection
    key: ID
}

type ArticleConnectionUpdated_at {
    connection: ArticleConnection
    key: DateTime
}

type ArticleGroupBy {
    content: [ArticleConnectionContent]
    created_at: [ArticleConnectionCreated_at]
    forPerson: [ArticleConnectionForPerson]
    id: [ArticleConnectionId]
    name: [ArticleConnectionName]
    post: [ArticleConnectionPost]
    published_at: [ArticleConnectionPublished_at]
    questionnaire: [ArticleConnectionQuestionnaire]
    subject: [ArticleConnectionSubject]
    updated_at: [ArticleConnectionUpdated_at]
}

type AssessmentQuestionnaire {
    content: String!
    created_at: DateTime!
    forPerson: ComponentDataFor
    game: Game
    id: ID!
    level: Int
    media(limit: Int, sort: String, start: Int, where: JSON): [UploadFile]
    name: String!
    period_length: Int!
    post: ComponentContentPost
    product: ComponentContentProduct
    questionnaire: Questionnaire
    questionnaireOnly: Boolean!
    subject: ComponentDataEhrSubject
    updated_at: DateTime!
}

type AssessmentQuestionnaireAggregator {
    avg: AssessmentQuestionnaireAggregatorAvg
    count: Int
    max: AssessmentQuestionnaireAggregatorMax
    min: AssessmentQuestionnaireAggregatorMin
    sum: AssessmentQuestionnaireAggregatorSum
    totalCount: Int
}

type AssessmentQuestionnaireAggregatorAvg {
    level: Float
    period_length: Float
}

type AssessmentQuestionnaireAggregatorMax {
    level: Float
    period_length: Float
}

type AssessmentQuestionnaireAggregatorMin {
    level: Float
    period_length: Float
}

type AssessmentQuestionnaireAggregatorSum {
    level: Float
    period_length: Float
}

type AssessmentQuestionnaireConnection {
    aggregate: AssessmentQuestionnaireAggregator
    groupBy: AssessmentQuestionnaireGroupBy
    values: [AssessmentQuestionnaire]
}

type AssessmentQuestionnaireConnectionContent {
    connection: AssessmentQuestionnaireConnection
    key: String
}

type AssessmentQuestionnaireConnectionCreated_at {
    connection: AssessmentQuestionnaireConnection
    key: DateTime
}

type AssessmentQuestionnaireConnectionForPerson {
    connection: AssessmentQuestionnaireConnection
    key: ID
}

type AssessmentQuestionnaireConnectionGame {
    connection: AssessmentQuestionnaireConnection
    key: ID
}

type AssessmentQuestionnaireConnectionId {
    connection: AssessmentQuestionnaireConnection
    key: ID
}

type AssessmentQuestionnaireConnectionLevel {
    connection: AssessmentQuestionnaireConnection
    key: Int
}

type AssessmentQuestionnaireConnectionName {
    connection: AssessmentQuestionnaireConnection
    key: String
}

type AssessmentQuestionnaireConnectionPeriod_length {
    connection: AssessmentQuestionnaireConnection
    key: Int
}

type AssessmentQuestionnaireConnectionPost {
    connection: AssessmentQuestionnaireConnection
    key: ID
}

type AssessmentQuestionnaireConnectionProduct {
    connection: AssessmentQuestionnaireConnection
    key: ID
}

type AssessmentQuestionnaireConnectionQuestionnaire {
    connection: AssessmentQuestionnaireConnection
    key: ID
}

type AssessmentQuestionnaireConnectionQuestionnaireOnly {
    connection: AssessmentQuestionnaireConnection
    key: Boolean
}

type AssessmentQuestionnaireConnectionSubject {
    connection: AssessmentQuestionnaireConnection
    key: ID
}

type AssessmentQuestionnaireConnectionUpdated_at {
    connection: AssessmentQuestionnaireConnection
    key: DateTime
}

type AssessmentQuestionnaireGroupBy {
    content: [AssessmentQuestionnaireConnectionContent]
    created_at: [AssessmentQuestionnaireConnectionCreated_at]
    forPerson: [AssessmentQuestionnaireConnectionForPerson]
    game: [AssessmentQuestionnaireConnectionGame]
    id: [AssessmentQuestionnaireConnectionId]
    level: [AssessmentQuestionnaireConnectionLevel]
    name: [AssessmentQuestionnaireConnectionName]
    period_length: [AssessmentQuestionnaireConnectionPeriod_length]
    post: [AssessmentQuestionnaireConnectionPost]
    product: [AssessmentQuestionnaireConnectionProduct]
    questionnaire: [AssessmentQuestionnaireConnectionQuestionnaire]
    questionnaireOnly: [AssessmentQuestionnaireConnectionQuestionnaireOnly]
    subject: [AssessmentQuestionnaireConnectionSubject]
    updated_at: [AssessmentQuestionnaireConnectionUpdated_at]
}

type AssessmentTermOfService {
    created_at: DateTime!
    id: ID!
    term_of_service: String
    updated_at: DateTime!
}

type Book {
    content: String!
    created_at: DateTime!
    episodes: [ComponentContentEpisode]
    id: ID!
    name: String!
    post: ComponentContentPost
    product: ComponentContentProduct
    type: BookType
    updated_at: DateTime!
}

type BookAggregator {
    count: Int
    totalCount: Int
}

type BookConnection {
    aggregate: BookAggregator
    groupBy: BookGroupBy
    values: [Book]
}

type BookConnectionContent {
    connection: BookConnection
    key: String
}

type BookConnectionCreated_at {
    connection: BookConnection
    key: DateTime
}

type BookConnectionId {
    connection: BookConnection
    key: ID
}

type BookConnectionName {
    connection: BookConnection
    key: String
}

type BookConnectionPost {
    connection: BookConnection
    key: ID
}

type BookConnectionProduct {
    connection: BookConnection
    key: ID
}

type BookConnectionType {
    connection: BookConnection
    key: String
}

type BookConnectionUpdated_at {
    connection: BookConnection
    key: DateTime
}

type BookGroupBy {
    content: [BookConnectionContent]
    created_at: [BookConnectionCreated_at]
    id: [BookConnectionId]
    name: [BookConnectionName]
    post: [BookConnectionPost]
    product: [BookConnectionProduct]
    type: [BookConnectionType]
    updated_at: [BookConnectionUpdated_at]
}

type Category {
    created_at: DateTime!
    id: ID!
    name: String!
    type: CategoryType
    updated_at: DateTime!
}

type CategoryAggregator {
    count: Int
    totalCount: Int
}

type CategoryConnection {
    aggregate: CategoryAggregator
    groupBy: CategoryGroupBy
    values: [Category]
}

type CategoryConnectionCreated_at {
    connection: CategoryConnection
    key: DateTime
}

type CategoryConnectionId {
    connection: CategoryConnection
    key: ID
}

type CategoryConnectionName {
    connection: CategoryConnection
    key: String
}

type CategoryConnectionType {
    connection: CategoryConnection
    key: String
}

type CategoryConnectionUpdated_at {
    connection: CategoryConnection
    key: DateTime
}

type CategoryGroupBy {
    created_at: [CategoryConnectionCreated_at]
    id: [CategoryConnectionId]
    name: [CategoryConnectionName]
    type: [CategoryConnectionType]
    updated_at: [CategoryConnectionUpdated_at]
}

type Classification {
    created_at: DateTime!
    id: ID!
    name: String
    published_at: DateTime
    sortIndex: Int
    updated_at: DateTime!
}

type ClassificationAggregator {
    avg: ClassificationAggregatorAvg
    count: Int
    max: ClassificationAggregatorMax
    min: ClassificationAggregatorMin
    sum: ClassificationAggregatorSum
    totalCount: Int
}

type ClassificationAggregatorAvg {
    sortIndex: Float
}

type ClassificationAggregatorMax {
    sortIndex: Float
}

type ClassificationAggregatorMin {
    sortIndex: Float
}

type ClassificationAggregatorSum {
    sortIndex: Float
}

type ClassificationConnection {
    aggregate: ClassificationAggregator
    groupBy: ClassificationGroupBy
    values: [Classification]
}

type ClassificationConnectionCreated_at {
    connection: ClassificationConnection
    key: DateTime
}

type ClassificationConnectionId {
    connection: ClassificationConnection
    key: ID
}

type ClassificationConnectionName {
    connection: ClassificationConnection
    key: String
}

type ClassificationConnectionPublished_at {
    connection: ClassificationConnection
    key: DateTime
}

type ClassificationConnectionSortIndex {
    connection: ClassificationConnection
    key: Int
}

type ClassificationConnectionUpdated_at {
    connection: ClassificationConnection
    key: DateTime
}

type ClassificationGroupBy {
    created_at: [ClassificationConnectionCreated_at]
    id: [ClassificationConnectionId]
    name: [ClassificationConnectionName]
    published_at: [ClassificationConnectionPublished_at]
    sortIndex: [ClassificationConnectionSortIndex]
    updated_at: [ClassificationConnectionUpdated_at]
}

type Color {
    color: String
    created_at: DateTime!
    id: ID!
    updated_at: DateTime!
}

type ColorAggregator {
    count: Int
    totalCount: Int
}

type ColorConnection {
    aggregate: ColorAggregator
    groupBy: ColorGroupBy
    values: [Color]
}

type ColorConnectionColor {
    connection: ColorConnection
    key: String
}

type ColorConnectionCreated_at {
    connection: ColorConnection
    key: DateTime
}

type ColorConnectionId {
    connection: ColorConnection
    key: ID
}

type ColorConnectionUpdated_at {
    connection: ColorConnection
    key: DateTime
}

type ColorGroupBy {
    color: [ColorConnectionColor]
    created_at: [ColorConnectionCreated_at]
    id: [ColorConnectionId]
    updated_at: [ColorConnectionUpdated_at]
}

type ComponentContentEpisode {
    content: String
    id: ID!
    subtitle: String
    title: String
}

type ComponentContentEventComponent {
    contacts: String
    dateTime: DateTime!
    email: String
    eventPrices: [ComponentContentEventPrice]
    eventVenue: Venue
    host: String
    id: ID!
    meetingId: String
    phoneNumber: String
}

type ComponentContentEventPrice {
    currency: PaymentCurrency
    id: ID!
    name: String!
    prePrice: Float
    price: Float!
}

type ComponentContentPost {
    author: UsersPermissionsUser
    categories(limit: Int, sort: String, start: Int, where: JSON): [Category]
    cover_background_color: Color
    currency: PaymentCurrency
    id: ID!
    image(limit: Int, sort: String, start: Int, where: JSON): [UploadFile]
    needShipping: Boolean
    prePrice: Float
    price: Float
    rating: Int
    recommended: Boolean
    status: PostStatus!
    subtitle: String
    title: String!
    trademark: Trademark
    updated_day: Date!
    vipText: String
    vip_color: Color
}

type ComponentContentProduct {
    content: String
    currency: PaymentCurrency
    id: ID!
    inventory: Int
    name: String
    preUnitPrice: Float
    provider: Provider
    shipping: Boolean
    unitPrice: Float
}

type ComponentContentSummary {
    id: ID!
    rating: Int
    subject: SummarySubject!
    type: SummaryType!
}

type ComponentDataAddress {
    address1: String
    address2: String
    address3: String
    city: String
    country: String
    fullName: String
    id: ID!
    postalCode: String
    state: String
}

type ComponentDataEhrSubject {
    id: ID!
    type: EhrSubject
}

type ComponentDataEhrType {
    id: ID!
    type: EhrType!
}

type ComponentDataFor {
    id: ID!
    type: ForType!
}

type ComponentDataPosition {
    altitude: Float
    head: Float
    id: ID!
    latitude: Float
    longitude: Float
    speed: Float
    timestamp: DateTime
}

type ComponentUserAuthor {
    foo: String
    id: ID!
}

type ComponentUserChild {
    id: ID!
    relationToUser: RelationType!
    schools(limit: Int, sort: String, start: Int, where: JSON): [School]
    teacher: UsersPermissionsUser
}

type ComponentUserCounselor {
    id: ID!
    location: Location
    patients(limit: Int, sort: String, start: Int, where: JSON): [Patient]
}

type ComponentUserDoctor {
    id: ID!
    location: Location
    patients(limit: Int, sort: String, start: Int, where: JSON): [Patient]
    subject: DoctorSubject!
}

type ComponentUserNurse {
    id: ID!
    location: Location
    patients(limit: Int, sort: String, start: Int, where: JSON): [Patient]
}

type ComponentUserParent {
    children(limit: Int, sort: String, start: Int, where: JSON): [UsersPermissionsUser]
    id: ID!
}

type ComponentUserPatient {
    counselor: UsersPermissionsUser
    doctor: UsersPermissionsUser
    id: ID!
    nurse: UsersPermissionsUser
}

type ComponentUserTeacher {
    atSchool: School
    children(limit: Int, sort: String, start: Int, where: JSON): [UsersPermissionsUser]
    id: ID!
    role: String
    school: String
}

type Course {
    content: String
    contentType: ContentType
    created_at: DateTime!
    id: ID!
    medias(limit: Int, sort: String, start: Int, where: JSON): [UploadFile]
    picture: UploadFile
    subtitle: String
    title: String
    updated_at: DateTime!
}

type CourseAggregator {
    count: Int
    totalCount: Int
}

type CourseConnection {
    aggregate: CourseAggregator
    groupBy: CourseGroupBy
    values: [Course]
}

type CourseConnectionContent {
    connection: CourseConnection
    key: String
}

type CourseConnectionContentType {
    connection: CourseConnection
    key: String
}

type CourseConnectionCreated_at {
    connection: CourseConnection
    key: DateTime
}

type CourseConnectionId {
    connection: CourseConnection
    key: ID
}

type CourseConnectionPicture {
    connection: CourseConnection
    key: ID
}

type CourseConnectionSubtitle {
    connection: CourseConnection
    key: String
}

type CourseConnectionTitle {
    connection: CourseConnection
    key: String
}

type CourseConnectionUpdated_at {
    connection: CourseConnection
    key: DateTime
}

type CourseGroupBy {
    content: [CourseConnectionContent]
    contentType: [CourseConnectionContentType]
    created_at: [CourseConnectionCreated_at]
    id: [CourseConnectionId]
    picture: [CourseConnectionPicture]
    subtitle: [CourseConnectionSubtitle]
    title: [CourseConnectionTitle]
    updated_at: [CourseConnectionUpdated_at]
}

type CreditCard {
    address: UserAddress
    created_at: DateTime!
    cvc: String!
    expMonth: Int!
    expYear: Int!
    id: ID!
    name: String!
    number: String!
    updated_at: DateTime!
    user: UsersPermissionsUser
}

type CreditCardAggregator {
    avg: CreditCardAggregatorAvg
    count: Int
    max: CreditCardAggregatorMax
    min: CreditCardAggregatorMin
    sum: CreditCardAggregatorSum
    totalCount: Int
}

type CreditCardAggregatorAvg {
    expMonth: Float
    expYear: Float
}

type CreditCardAggregatorMax {
    expMonth: Float
    expYear: Float
}

type CreditCardAggregatorMin {
    expMonth: Float
    expYear: Float
}

type CreditCardAggregatorSum {
    expMonth: Float
    expYear: Float
}

type CreditCardConnection {
    aggregate: CreditCardAggregator
    groupBy: CreditCardGroupBy
    values: [CreditCard]
}

type CreditCardConnectionAddress {
    connection: CreditCardConnection
    key: ID
}

type CreditCardConnectionCreated_at {
    connection: CreditCardConnection
    key: DateTime
}

type CreditCardConnectionCvc {
    connection: CreditCardConnection
    key: String
}

type CreditCardConnectionExpMonth {
    connection: CreditCardConnection
    key: Int
}

type CreditCardConnectionExpYear {
    connection: CreditCardConnection
    key: Int
}

type CreditCardConnectionId {
    connection: CreditCardConnection
    key: ID
}

type CreditCardConnectionName {
    connection: CreditCardConnection
    key: String
}

type CreditCardConnectionNumber {
    connection: CreditCardConnection
    key: String
}

type CreditCardConnectionUpdated_at {
    connection: CreditCardConnection
    key: DateTime
}

type CreditCardConnectionUser {
    connection: CreditCardConnection
    key: ID
}

type CreditCardGroupBy {
    address: [CreditCardConnectionAddress]
    created_at: [CreditCardConnectionCreated_at]
    cvc: [CreditCardConnectionCvc]
    expMonth: [CreditCardConnectionExpMonth]
    expYear: [CreditCardConnectionExpYear]
    id: [CreditCardConnectionId]
    name: [CreditCardConnectionName]
    number: [CreditCardConnectionNumber]
    updated_at: [CreditCardConnectionUpdated_at]
    user: [CreditCardConnectionUser]
}

type Ehr {
    classification: Classification
    created_at: DateTime!
    id: ID!
    medias(limit: Int, sort: String, start: Int, where: JSON): [UploadFile]
    office_comments: String
    patient: Patient
    position: ComponentDataPosition
    questionnaire_answer: QuestionnaireAnswer
    record: JSON
    source: String!
    source_id: String!
    status: EhrStatus!
    subject: ComponentDataEhrSubject
    summaries: [ComponentContentSummary]
    updated_at: DateTime!
}

type EhrAggregator {
    count: Int
    totalCount: Int
}

type EhrConnection {
    aggregate: EhrAggregator
    groupBy: EhrGroupBy
    values: [Ehr]
}

type EhrConnectionClassification {
    connection: EhrConnection
    key: ID
}

type EhrConnectionCreated_at {
    connection: EhrConnection
    key: DateTime
}

type EhrConnectionId {
    connection: EhrConnection
    key: ID
}

type EhrConnectionOffice_comments {
    connection: EhrConnection
    key: String
}

type EhrConnectionPatient {
    connection: EhrConnection
    key: ID
}

type EhrConnectionPosition {
    connection: EhrConnection
    key: ID
}

type EhrConnectionQuestionnaire_answer {
    connection: EhrConnection
    key: ID
}

type EhrConnectionRecord {
    connection: EhrConnection
    key: JSON
}

type EhrConnectionSource {
    connection: EhrConnection
    key: String
}

type EhrConnectionSource_id {
    connection: EhrConnection
    key: String
}

type EhrConnectionStatus {
    connection: EhrConnection
    key: String
}

type EhrConnectionSubject {
    connection: EhrConnection
    key: ID
}

type EhrConnectionUpdated_at {
    connection: EhrConnection
    key: DateTime
}

type EhrGroupBy {
    classification: [EhrConnectionClassification]
    created_at: [EhrConnectionCreated_at]
    id: [EhrConnectionId]
    office_comments: [EhrConnectionOffice_comments]
    patient: [EhrConnectionPatient]
    position: [EhrConnectionPosition]
    questionnaire_answer: [EhrConnectionQuestionnaire_answer]
    record: [EhrConnectionRecord]
    source: [EhrConnectionSource]
    source_id: [EhrConnectionSource_id]
    status: [EhrConnectionStatus]
    subject: [EhrConnectionSubject]
    updated_at: [EhrConnectionUpdated_at]
}

type Event {
    content: String
    created_at: DateTime!
    dicount: Float
    eventComponent: ComponentContentEventComponent
    id: ID!
    name: String!
    post: ComponentContentPost
    updated_at: DateTime!
}

type EventAggregator {
    avg: EventAggregatorAvg
    count: Int
    max: EventAggregatorMax
    min: EventAggregatorMin
    sum: EventAggregatorSum
    totalCount: Int
}

type EventAggregatorAvg {
    dicount: Float
}

type EventAggregatorMax {
    dicount: Float
}

type EventAggregatorMin {
    dicount: Float
}

type EventAggregatorSum {
    dicount: Float
}

type EventConnection {
    aggregate: EventAggregator
    groupBy: EventGroupBy
    values: [Event]
}

type EventConnectionContent {
    connection: EventConnection
    key: String
}

type EventConnectionCreated_at {
    connection: EventConnection
    key: DateTime
}

type EventConnectionDicount {
    connection: EventConnection
    key: Float
}

type EventConnectionEventComponent {
    connection: EventConnection
    key: ID
}

type EventConnectionId {
    connection: EventConnection
    key: ID
}

type EventConnectionName {
    connection: EventConnection
    key: String
}

type EventConnectionPost {
    connection: EventConnection
    key: ID
}

type EventConnectionUpdated_at {
    connection: EventConnection
    key: DateTime
}

type EventGroupBy {
    content: [EventConnectionContent]
    created_at: [EventConnectionCreated_at]
    dicount: [EventConnectionDicount]
    eventComponent: [EventConnectionEventComponent]
    id: [EventConnectionId]
    name: [EventConnectionName]
    post: [EventConnectionPost]
    updated_at: [EventConnectionUpdated_at]
}

type Exercise {
    age: Int
    content: String!
    created_at: DateTime!
    forPerson: ComponentDataFor
    game: Game
    id: ID!
    level: Int
    post: ComponentContentPost
    questionnaire: Questionnaire
    subject: ComponentDataEhrSubject
    type: ExerciseType!
    updated_at: DateTime!
}

type ExerciseAggregator {
    avg: ExerciseAggregatorAvg
    count: Int
    max: ExerciseAggregatorMax
    min: ExerciseAggregatorMin
    sum: ExerciseAggregatorSum
    totalCount: Int
}

type ExerciseAggregatorAvg {
    age: Float
    level: Float
}

type ExerciseAggregatorMax {
    age: Float
    level: Float
}

type ExerciseAggregatorMin {
    age: Float
    level: Float
}

type ExerciseAggregatorSum {
    age: Float
    level: Float
}

type ExerciseConnection {
    aggregate: ExerciseAggregator
    groupBy: ExerciseGroupBy
    values: [Exercise]
}

type ExerciseConnectionAge {
    connection: ExerciseConnection
    key: Int
}

type ExerciseConnectionContent {
    connection: ExerciseConnection
    key: String
}

type ExerciseConnectionCreated_at {
    connection: ExerciseConnection
    key: DateTime
}

type ExerciseConnectionForPerson {
    connection: ExerciseConnection
    key: ID
}

type ExerciseConnectionGame {
    connection: ExerciseConnection
    key: ID
}

type ExerciseConnectionId {
    connection: ExerciseConnection
    key: ID
}

type ExerciseConnectionLevel {
    connection: ExerciseConnection
    key: Int
}

type ExerciseConnectionPost {
    connection: ExerciseConnection
    key: ID
}

type ExerciseConnectionQuestionnaire {
    connection: ExerciseConnection
    key: ID
}

type ExerciseConnectionSubject {
    connection: ExerciseConnection
    key: ID
}

type ExerciseConnectionType {
    connection: ExerciseConnection
    key: String
}

type ExerciseConnectionUpdated_at {
    connection: ExerciseConnection
    key: DateTime
}

type ExerciseGroupBy {
    age: [ExerciseConnectionAge]
    content: [ExerciseConnectionContent]
    created_at: [ExerciseConnectionCreated_at]
    forPerson: [ExerciseConnectionForPerson]
    game: [ExerciseConnectionGame]
    id: [ExerciseConnectionId]
    level: [ExerciseConnectionLevel]
    post: [ExerciseConnectionPost]
    questionnaire: [ExerciseConnectionQuestionnaire]
    subject: [ExerciseConnectionSubject]
    type: [ExerciseConnectionType]
    updated_at: [ExerciseConnectionUpdated_at]
}

type FlowchartTest {
    chart: String
    id: ID!
}

type Game {
    content: String
    cptLevel: Int!
    created_at: DateTime!
    id: ID!
    medias(limit: Int, sort: String, start: Int, where: JSON): [UploadFile]
    name: String!
    provider: String
    trademark: Trademark
    type: GameType!
    updated_at: DateTime!
}

type GameAggregator {
    avg: GameAggregatorAvg
    count: Int
    max: GameAggregatorMax
    min: GameAggregatorMin
    sum: GameAggregatorSum
    totalCount: Int
}

type GameAggregatorAvg {
    cptLevel: Float
}

type GameAggregatorMax {
    cptLevel: Float
}

type GameAggregatorMin {
    cptLevel: Float
}

type GameAggregatorSum {
    cptLevel: Float
}

type GameConnection {
    aggregate: GameAggregator
    groupBy: GameGroupBy
    values: [Game]
}

type GameConnectionContent {
    connection: GameConnection
    key: String
}

type GameConnectionCptLevel {
    connection: GameConnection
    key: Int
}

type GameConnectionCreated_at {
    connection: GameConnection
    key: DateTime
}

type GameConnectionId {
    connection: GameConnection
    key: ID
}

type GameConnectionName {
    connection: GameConnection
    key: String
}

type GameConnectionProvider {
    connection: GameConnection
    key: String
}

type GameConnectionTrademark {
    connection: GameConnection
    key: ID
}

type GameConnectionType {
    connection: GameConnection
    key: String
}

type GameConnectionUpdated_at {
    connection: GameConnection
    key: DateTime
}

type GameGroupBy {
    content: [GameConnectionContent]
    cptLevel: [GameConnectionCptLevel]
    created_at: [GameConnectionCreated_at]
    id: [GameConnectionId]
    name: [GameConnectionName]
    provider: [GameConnectionProvider]
    trademark: [GameConnectionTrademark]
    type: [GameConnectionType]
    updated_at: [GameConnectionUpdated_at]
}

type Location {
    address: String!
    content: String
    counselors(limit: Int, sort: String, start: Int, where: JSON): [UsersPermissionsUser]
    created_at: DateTime!
    description: String
    doctors(limit: Int, sort: String, start: Int, where: JSON): [UsersPermissionsUser]
    email: String
    id: ID!
    name: String!
    nurses(limit: Int, sort: String, start: Int, where: JSON): [UsersPermissionsUser]
    phone: String
    post: ComponentContentPost
    qrCode: UploadFile
    type: LocationType!
    updated_at: DateTime!
    web: String
}

type LocationAggregator {
    count: Int
    totalCount: Int
}

type LocationConnection {
    aggregate: LocationAggregator
    groupBy: LocationGroupBy
    values: [Location]
}

type LocationConnectionAddress {
    connection: LocationConnection
    key: String
}

type LocationConnectionContent {
    connection: LocationConnection
    key: String
}

type LocationConnectionCreated_at {
    connection: LocationConnection
    key: DateTime
}

type LocationConnectionDescription {
    connection: LocationConnection
    key: String
}

type LocationConnectionEmail {
    connection: LocationConnection
    key: String
}

type LocationConnectionId {
    connection: LocationConnection
    key: ID
}

type LocationConnectionName {
    connection: LocationConnection
    key: String
}

type LocationConnectionPhone {
    connection: LocationConnection
    key: String
}

type LocationConnectionPost {
    connection: LocationConnection
    key: ID
}

type LocationConnectionQrCode {
    connection: LocationConnection
    key: ID
}

type LocationConnectionType {
    connection: LocationConnection
    key: String
}

type LocationConnectionUpdated_at {
    connection: LocationConnection
    key: DateTime
}

type LocationConnectionWeb {
    connection: LocationConnection
    key: String
}

type LocationGroupBy {
    address: [LocationConnectionAddress]
    content: [LocationConnectionContent]
    created_at: [LocationConnectionCreated_at]
    description: [LocationConnectionDescription]
    email: [LocationConnectionEmail]
    id: [LocationConnectionId]
    name: [LocationConnectionName]
    phone: [LocationConnectionPhone]
    post: [LocationConnectionPost]
    qrCode: [LocationConnectionQrCode]
    type: [LocationConnectionType]
    updated_at: [LocationConnectionUpdated_at]
    web: [LocationConnectionWeb]
}

type Mutation {
    agreeTermOfService(input: agreeTermOfServiceInput): [UserAgreement]
    batchTelemetry(input: batchTelemetryInput!): batchTelemetryPayload!
    cancelOrder(input: cancelOrderInput): cancelOrderPayload
    createAccount(input: createAccountInput): createAccountPayload
    createArticle(input: createArticleInput): createArticlePayload
    createAssessmentQuestionnaire(input: createAssessmentQuestionnaireInput): createAssessmentQuestionnairePayload
    createBook(input: createBookInput): createBookPayload
    createCategory(input: createCategoryInput): createCategoryPayload
    createChild(input: createChildInput!): createUserPayload!
    createClassification(input: createClassificationInput): createClassificationPayload
    createColor(input: createColorInput): createColorPayload
    createCourse(input: createCourseInput): createCoursePayload
    createCreditCard(input: createCreditCardInput): createCreditCardPayload
    createCurrency(input: createCurrencyInput): createCurrencyPayload
    createEhr(input: createEhrInput): createEhrPayload
    createEvent(input: createEventInput): createEventPayload
    createExercise(input: createExerciseInput): createExercisePayload
    createGame(input: createGameInput): createGamePayload
    createLocation(input: createLocationInput): createLocationPayload
    createMyAddress(input: createMyAddressInput): createUserAddressPayload
    createMyOrder(input: createMyOrderInput): createOrderPayload
    createOrganizationUnit(input: createOrganizationUnitInput): createOrganizationUnitPayload
    createParenting(input: createParentingInput): createParentingPayload
    createPatient(input: createPatientInput): createPatientPayload
    createPaymentMethod(input: createPaymentMethodInput): createPaymentMethodPayload
    createPlan(input: createPlanInput): createPlanPayload
    createPost(input: createPostInput): createPostPayload
    createProvider(input: createProviderInput): createProviderPayload
    createQuestionnaire(input: createQuestionnaireInput): createQuestionnairePayload
    createQuestionnaireAnswer(input: createQuestionnaireAnswerInput): createQuestionnaireAnswerPayload
    createReminder(input: createReminderInput): createReminderPayload
    "Create a new role"
    createRole(input: createRoleInput): createRolePayload
    createSchool(input: createSchoolInput): createSchoolPayload
    createSupplement(input: createSupplementInput): createSupplementPayload
    createTelemetry(input: createTelemetryInput): createTelemetryPayload
    createTrademark(input: createTrademarkInput): createTrademarkPayload
    createUnifiedOrder(input: createUnifiedOrderInput): createOrderPayload
    "Create a new user"
    createUser(input: createUserInput): createUserPayload
    createUserAddress(input: createUserAddressInput): createUserAddressPayload
    createUserAgreement(input: createUserAgreementInput): createUserAgreementPayload
    createUserAssessment(input: createUserAssessmentInput): createUserAssessmentPayload
    createUserExercise(input: createUserExerciseInput): createUserExercisePayload
    createUserParenting(input: createUserParentingInput): createUserParentingPayload
    createUserPlan(input: createUserPlanInput): createUserPlanPayload
    createVenue(input: createVenueInput): createVenuePayload
    createWebinar(input: createWebinarInput): createWebinarPayload
    deleteAboutFastBraiin: deleteAboutFastBraiinPayload
    deleteAccount(input: deleteAccountInput): deleteAccountPayload
    deleteAppTermOfService: deleteAppTermOfServicePayload
    deleteArticle(input: deleteArticleInput): deleteArticlePayload
    deleteAssessmentQuestionnaire(input: deleteAssessmentQuestionnaireInput): deleteAssessmentQuestionnairePayload
    deleteAssessmentTermOfService: deleteAssessmentTermOfServicePayload
    deleteBook(input: deleteBookInput): deleteBookPayload
    deleteCategory(input: deleteCategoryInput): deleteCategoryPayload
    deleteClassification(input: deleteClassificationInput): deleteClassificationPayload
    deleteColor(input: deleteColorInput): deleteColorPayload
    deleteCourse(input: deleteCourseInput): deleteCoursePayload
    deleteCreditCard(input: deleteCreditCardInput): deleteCreditCardPayload
    deleteCurrency(input: deleteCurrencyInput): deleteCurrencyPayload
    deleteEhr(input: deleteEhrInput): deleteEhrPayload
    deleteEvent(input: deleteEventInput): deleteEventPayload
    deleteExercise(input: deleteExerciseInput): deleteExercisePayload
    "Delete one file"
    deleteFile(input: deleteFileInput): deleteFilePayload
    deleteGame(input: deleteGameInput): deleteGamePayload
    deleteLocation(input: deleteLocationInput): deleteLocationPayload
    deleteMyAddress(input: deleteUserAddressInput): deleteUserAddressPayload
    deleteOrder(input: deleteOrderInput): deleteOrderPayload
    deleteOrganizationUnit(input: deleteOrganizationUnitInput): deleteOrganizationUnitPayload
    deleteParenting(input: deleteParentingInput): deleteParentingPayload
    deletePatient(input: deletePatientInput): deletePatientPayload
    deletePaymentMethod(input: deletePaymentMethodInput): deletePaymentMethodPayload
    deletePaymentPolicy: deletePaymentPolicyPayload
    deletePlan(input: deletePlanInput): deletePlanPayload
    deletePost(input: deletePostInput): deletePostPayload
    deleteProvider(input: deleteProviderInput): deleteProviderPayload
    deleteQuestionnaire(input: deleteQuestionnaireInput): deleteQuestionnairePayload
    deleteQuestionnaireAnswer(input: deleteQuestionnaireAnswerInput): deleteQuestionnaireAnswerPayload
    deleteReminder(input: deleteReminderInput): deleteReminderPayload
    "Delete an existing role"
    deleteRole(input: deleteRoleInput): deleteRolePayload
    deleteSchool(input: deleteSchoolInput): deleteSchoolPayload
    deleteSupplement(input: deleteSupplementInput): deleteSupplementPayload
    deleteTelemetry(input: deleteTelemetryInput): deleteTelemetryPayload
    deleteTrademark(input: deleteTrademarkInput): deleteTrademarkPayload
    "Delete an existing user"
    deleteUser(input: deleteUserInput): deleteUserPayload
    deleteUserAddress(input: deleteUserAddressInput): deleteUserAddressPayload
    deleteUserAgreement(input: deleteUserAgreementInput): deleteUserAgreementPayload
    deleteUserAssessment(input: deleteUserAssessmentInput): deleteUserAssessmentPayload
    deleteUserExercise(input: deleteUserExerciseInput): deleteUserExercisePayload
    deleteUserParenting(input: deleteUserParentingInput): deleteUserParentingPayload
    deleteUserPlan(input: deleteUserPlanInput): deleteUserPlanPayload
    deleteVenue(input: deleteVenueInput): deleteVenuePayload
    deleteVersion: deleteVersionPayload
    deleteWebinar(input: deleteWebinarInput): deleteWebinarPayload
    emailConfirmation(confirmation: String!): UsersPermissionsLoginPayload
    forgotPassword(email: String!): UserPermissionsPasswordPayload
    login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!
    multipleUpload(field: String, files: [Upload]!, ref: String, refId: ID, source: String): [UploadFile]!
    refreshToken(jwt: String!): UsersPermissionsRefreshTokenPayload!
    register(input: UsersPermissionsRegisterInput!): UsersPermissionsLoginPayload!
    requestOrderPay(input: requestOrderPayInput): requestOrderPayPayload
    resetPassword(code: String!, password: String!, passwordConfirmation: String!): UsersPermissionsLoginPayload
    updateAboutFastBraiin(input: updateAboutFastBraiinInput): updateAboutFastBraiinPayload
    updateAccount(input: updateAccountInput): updateAccountPayload
    updateAppTermOfService(input: updateAppTermOfServiceInput): updateAppTermOfServicePayload
    updateArticle(input: updateArticleInput): updateArticlePayload
    updateAssessmentQuestionnaire(input: updateAssessmentQuestionnaireInput): updateAssessmentQuestionnairePayload
    updateAssessmentTermOfService(input: updateAssessmentTermOfServiceInput): updateAssessmentTermOfServicePayload
    updateBook(input: updateBookInput): updateBookPayload
    updateCategory(input: updateCategoryInput): updateCategoryPayload
    updateChild(input: updateChildInput!): updateUserPayload!
    updateClassification(input: updateClassificationInput): updateClassificationPayload
    updateColor(input: updateColorInput): updateColorPayload
    updateCourse(input: updateCourseInput): updateCoursePayload
    updateCreditCard(input: updateCreditCardInput): updateCreditCardPayload
    updateCurrency(input: updateCurrencyInput): updateCurrencyPayload
    updateEhr(input: updateEhrInput): updateEhrPayload
    updateEvent(input: updateEventInput): updateEventPayload
    updateExercise(input: updateExerciseInput): updateExercisePayload
    updateFileInfo(id: ID!, info: FileInfoInput!): UploadFile!
    updateGame(input: updateGameInput): updateGamePayload
    updateLocation(input: updateLocationInput): updateLocationPayload
    updateMe(input: updateMeInput): UsersPermissionsMe
    updateMyAddress(input: updateMyAddressInput): updateUserAddressPayload
    updateOrganizationUnit(input: updateOrganizationUnitInput): updateOrganizationUnitPayload
    updateParenting(input: updateParentingInput): updateParentingPayload
    updatePatient(input: updatePatientInput): updatePatientPayload
    updatePaymentMethod(input: updatePaymentMethodInput): updatePaymentMethodPayload
    updatePaymentPolicy(input: updatePaymentPolicyInput): updatePaymentPolicyPayload
    updatePlan(input: updatePlanInput): updatePlanPayload
    updatePost(input: updatePostInput): updatePostPayload
    updateProvider(input: updateProviderInput): updateProviderPayload
    updateQuestionnaire(input: updateQuestionnaireInput): updateQuestionnairePayload
    updateQuestionnaireAnswer(input: updateQuestionnaireAnswerInput): updateQuestionnaireAnswerPayload
    updateReminder(input: updateReminderInput): updateReminderPayload
    "Update an existing role"
    updateRole(input: updateRoleInput): updateRolePayload
    updateSchool(input: updateSchoolInput): updateSchoolPayload
    updateSupplement(input: updateSupplementInput): updateSupplementPayload
    updateTelemetry(input: updateTelemetryInput): updateTelemetryPayload
    updateTrademark(input: updateTrademarkInput): updateTrademarkPayload
    "Update an existing user"
    updateUser(input: updateUserInput): updateUserPayload
    updateUserAddress(input: updateUserAddressInput): updateUserAddressPayload
    updateUserAgreement(input: updateUserAgreementInput): updateUserAgreementPayload
    updateUserAssessment(input: updateUserAssessmentInput): updateUserAssessmentPayload
    updateUserExercise(input: updateUserExerciseInput): updateUserExercisePayload
    updateUserParenting(input: updateUserParentingInput): updateUserParentingPayload
    updateUserPlan(input: updateUserPlanInput): updateUserPlanPayload
    updateVenue(input: updateVenueInput): updateVenuePayload
    updateVersion(input: updateVersionInput): updateVersionPayload
    updateWebinar(input: updateWebinarInput): updateWebinarPayload
    upload(field: String, file: Upload!, info: FileInfoInput, ref: String, refId: ID, source: String): UploadFile!
}

type Parenting {
    content: String
    created_at: DateTime!
    id: ID!
    media(limit: Int, sort: String, start: Int, where: JSON): [UploadFile]
    name: String!
    pdfFiles: UploadFile
    post: ComponentContentPost
    questionnaire: Questionnaire
    subject: ComponentDataEhrSubject
    updated_at: DateTime!
}

type ParentingAggregator {
    count: Int
    totalCount: Int
}

type ParentingConnection {
    aggregate: ParentingAggregator
    groupBy: ParentingGroupBy
    values: [Parenting]
}

type ParentingConnectionContent {
    connection: ParentingConnection
    key: String
}

type ParentingConnectionCreated_at {
    connection: ParentingConnection
    key: DateTime
}

type ParentingConnectionId {
    connection: ParentingConnection
    key: ID
}

type ParentingConnectionName {
    connection: ParentingConnection
    key: String
}

type ParentingConnectionPdfFiles {
    connection: ParentingConnection
    key: ID
}

type ParentingConnectionPost {
    connection: ParentingConnection
    key: ID
}

type ParentingConnectionQuestionnaire {
    connection: ParentingConnection
    key: ID
}

type ParentingConnectionSubject {
    connection: ParentingConnection
    key: ID
}

type ParentingConnectionUpdated_at {
    connection: ParentingConnection
    key: DateTime
}

type ParentingGroupBy {
    content: [ParentingConnectionContent]
    created_at: [ParentingConnectionCreated_at]
    id: [ParentingConnectionId]
    name: [ParentingConnectionName]
    pdfFiles: [ParentingConnectionPdfFiles]
    post: [ParentingConnectionPost]
    questionnaire: [ParentingConnectionQuestionnaire]
    subject: [ParentingConnectionSubject]
    updated_at: [ParentingConnectionUpdated_at]
}

type Patient {
    counselor: UsersPermissionsUser
    created_at: DateTime!
    doctor: UsersPermissionsUser
    ehrs(limit: Int, sort: String, start: Int, where: JSON): [Ehr]
    id: ID!
    location: Location
    meetingId: String
    name: String!
    nurse: UsersPermissionsUser
    status: PatientStatus
    teacher: UsersPermissionsUser
    updated_at: DateTime!
    user: UsersPermissionsUser
}

type PatientAggregator {
    count: Int
    totalCount: Int
}

type PatientConnection {
    aggregate: PatientAggregator
    groupBy: PatientGroupBy
    values: [Patient]
}

type PatientConnectionCounselor {
    connection: PatientConnection
    key: ID
}

type PatientConnectionCreated_at {
    connection: PatientConnection
    key: DateTime
}

type PatientConnectionDoctor {
    connection: PatientConnection
    key: ID
}

type PatientConnectionId {
    connection: PatientConnection
    key: ID
}

type PatientConnectionLocation {
    connection: PatientConnection
    key: ID
}

type PatientConnectionMeetingId {
    connection: PatientConnection
    key: String
}

type PatientConnectionName {
    connection: PatientConnection
    key: String
}

type PatientConnectionNurse {
    connection: PatientConnection
    key: ID
}

type PatientConnectionStatus {
    connection: PatientConnection
    key: String
}

type PatientConnectionTeacher {
    connection: PatientConnection
    key: ID
}

type PatientConnectionUpdated_at {
    connection: PatientConnection
    key: DateTime
}

type PatientConnectionUser {
    connection: PatientConnection
    key: ID
}

type PatientGroupBy {
    counselor: [PatientConnectionCounselor]
    created_at: [PatientConnectionCreated_at]
    doctor: [PatientConnectionDoctor]
    id: [PatientConnectionId]
    location: [PatientConnectionLocation]
    meetingId: [PatientConnectionMeetingId]
    name: [PatientConnectionName]
    nurse: [PatientConnectionNurse]
    status: [PatientConnectionStatus]
    teacher: [PatientConnectionTeacher]
    updated_at: [PatientConnectionUpdated_at]
    user: [PatientConnectionUser]
}

type PaymentCurrency {
    code: String!
    created_at: DateTime!
    decimal_digits: Int!
    id: ID!
    name: String!
    name_plural: String
    rounding: Int!
    symbol: String!
    symbol_native: String
    updated_at: DateTime!
}

type PaymentCurrencyAggregator {
    avg: PaymentCurrencyAggregatorAvg
    count: Int
    max: PaymentCurrencyAggregatorMax
    min: PaymentCurrencyAggregatorMin
    sum: PaymentCurrencyAggregatorSum
    totalCount: Int
}

type PaymentCurrencyAggregatorAvg {
    decimal_digits: Float
    rounding: Float
}

type PaymentCurrencyAggregatorMax {
    decimal_digits: Float
    rounding: Float
}

type PaymentCurrencyAggregatorMin {
    decimal_digits: Float
    rounding: Float
}

type PaymentCurrencyAggregatorSum {
    decimal_digits: Float
    rounding: Float
}

type PaymentCurrencyConnection {
    aggregate: PaymentCurrencyAggregator
    groupBy: PaymentCurrencyGroupBy
    values: [PaymentCurrency]
}

type PaymentCurrencyConnectionCode {
    connection: PaymentCurrencyConnection
    key: String
}

type PaymentCurrencyConnectionCreated_at {
    connection: PaymentCurrencyConnection
    key: DateTime
}

type PaymentCurrencyConnectionDecimal_digits {
    connection: PaymentCurrencyConnection
    key: Int
}

type PaymentCurrencyConnectionId {
    connection: PaymentCurrencyConnection
    key: ID
}

type PaymentCurrencyConnectionName {
    connection: PaymentCurrencyConnection
    key: String
}

type PaymentCurrencyConnectionName_plural {
    connection: PaymentCurrencyConnection
    key: String
}

type PaymentCurrencyConnectionRounding {
    connection: PaymentCurrencyConnection
    key: Int
}

type PaymentCurrencyConnectionSymbol {
    connection: PaymentCurrencyConnection
    key: String
}

type PaymentCurrencyConnectionSymbol_native {
    connection: PaymentCurrencyConnection
    key: String
}

type PaymentCurrencyConnectionUpdated_at {
    connection: PaymentCurrencyConnection
    key: DateTime
}

type PaymentCurrencyGroupBy {
    code: [PaymentCurrencyConnectionCode]
    created_at: [PaymentCurrencyConnectionCreated_at]
    decimal_digits: [PaymentCurrencyConnectionDecimal_digits]
    id: [PaymentCurrencyConnectionId]
    name: [PaymentCurrencyConnectionName]
    name_plural: [PaymentCurrencyConnectionName_plural]
    rounding: [PaymentCurrencyConnectionRounding]
    symbol: [PaymentCurrencyConnectionSymbol]
    symbol_native: [PaymentCurrencyConnectionSymbol_native]
    updated_at: [PaymentCurrencyConnectionUpdated_at]
}

type PaymentMethod {
    billingAddress: UserAddress
    created_at: DateTime!
    creditCard: CreditCard
    id: ID!
    livemode: Boolean
    stripeId: String!
    type: String
    updated_at: DateTime!
    user: UsersPermissionsUser
}

type PaymentMethodAggregator {
    count: Int
    totalCount: Int
}

type PaymentMethodConnection {
    aggregate: PaymentMethodAggregator
    groupBy: PaymentMethodGroupBy
    values: [PaymentMethod]
}

type PaymentMethodConnectionBillingAddress {
    connection: PaymentMethodConnection
    key: ID
}

type PaymentMethodConnectionCreated_at {
    connection: PaymentMethodConnection
    key: DateTime
}

type PaymentMethodConnectionCreditCard {
    connection: PaymentMethodConnection
    key: ID
}

type PaymentMethodConnectionId {
    connection: PaymentMethodConnection
    key: ID
}

type PaymentMethodConnectionLivemode {
    connection: PaymentMethodConnection
    key: Boolean
}

type PaymentMethodConnectionStripeId {
    connection: PaymentMethodConnection
    key: String
}

type PaymentMethodConnectionType {
    connection: PaymentMethodConnection
    key: String
}

type PaymentMethodConnectionUpdated_at {
    connection: PaymentMethodConnection
    key: DateTime
}

type PaymentMethodConnectionUser {
    connection: PaymentMethodConnection
    key: ID
}

type PaymentMethodGroupBy {
    billingAddress: [PaymentMethodConnectionBillingAddress]
    created_at: [PaymentMethodConnectionCreated_at]
    creditCard: [PaymentMethodConnectionCreditCard]
    id: [PaymentMethodConnectionId]
    livemode: [PaymentMethodConnectionLivemode]
    stripeId: [PaymentMethodConnectionStripeId]
    type: [PaymentMethodConnectionType]
    updated_at: [PaymentMethodConnectionUpdated_at]
    user: [PaymentMethodConnectionUser]
}

type PaymentOrder {
    additional: JSON
    created_at: DateTime!
    currency: PaymentCurrency
    description: String
    expire: DateTime
    id: ID!
    items(limit: Int, sort: String, start: Int, where: JSON): [PaymentOrderItem]
    needpayPrice: Float
    outTradeId: String
    outTradeProvider: String
    paiedPrice: Float
    price: Float
    shippingAddress: ComponentDataAddress
    status: OrderStatusType
    updated_at: DateTime!
    user: UsersPermissionsUser
    uuid: String
}

type PaymentOrderAggregator {
    avg: PaymentOrderAggregatorAvg
    count: Int
    max: PaymentOrderAggregatorMax
    min: PaymentOrderAggregatorMin
    sum: PaymentOrderAggregatorSum
    totalCount: Int
}

type PaymentOrderAggregatorAvg {
    needpayPrice: Float
    paiedPrice: Float
    price: Float
}

type PaymentOrderAggregatorMax {
    needpayPrice: Float
    paiedPrice: Float
    price: Float
}

type PaymentOrderAggregatorMin {
    needpayPrice: Float
    paiedPrice: Float
    price: Float
}

type PaymentOrderAggregatorSum {
    needpayPrice: Float
    paiedPrice: Float
    price: Float
}

type PaymentOrderConnection {
    aggregate: PaymentOrderAggregator
    groupBy: PaymentOrderGroupBy
    values: [PaymentOrder]
}

type PaymentOrderConnectionAdditional {
    connection: PaymentOrderConnection
    key: JSON
}

type PaymentOrderConnectionCreated_at {
    connection: PaymentOrderConnection
    key: DateTime
}

type PaymentOrderConnectionCurrency {
    connection: PaymentOrderConnection
    key: ID
}

type PaymentOrderConnectionDescription {
    connection: PaymentOrderConnection
    key: String
}

type PaymentOrderConnectionExpire {
    connection: PaymentOrderConnection
    key: DateTime
}

type PaymentOrderConnectionId {
    connection: PaymentOrderConnection
    key: ID
}

type PaymentOrderConnectionNeedpayPrice {
    connection: PaymentOrderConnection
    key: Float
}

type PaymentOrderConnectionOutTradeId {
    connection: PaymentOrderConnection
    key: String
}

type PaymentOrderConnectionOutTradeProvider {
    connection: PaymentOrderConnection
    key: String
}

type PaymentOrderConnectionPaiedPrice {
    connection: PaymentOrderConnection
    key: Float
}

type PaymentOrderConnectionPrice {
    connection: PaymentOrderConnection
    key: Float
}

type PaymentOrderConnectionShippingAddress {
    connection: PaymentOrderConnection
    key: ID
}

type PaymentOrderConnectionStatus {
    connection: PaymentOrderConnection
    key: String
}

type PaymentOrderConnectionUpdated_at {
    connection: PaymentOrderConnection
    key: DateTime
}

type PaymentOrderConnectionUser {
    connection: PaymentOrderConnection
    key: ID
}

type PaymentOrderConnectionUuid {
    connection: PaymentOrderConnection
    key: String
}

type PaymentOrderGroupBy {
    additional: [PaymentOrderConnectionAdditional]
    created_at: [PaymentOrderConnectionCreated_at]
    currency: [PaymentOrderConnectionCurrency]
    description: [PaymentOrderConnectionDescription]
    expire: [PaymentOrderConnectionExpire]
    id: [PaymentOrderConnectionId]
    needpayPrice: [PaymentOrderConnectionNeedpayPrice]
    outTradeId: [PaymentOrderConnectionOutTradeId]
    outTradeProvider: [PaymentOrderConnectionOutTradeProvider]
    paiedPrice: [PaymentOrderConnectionPaiedPrice]
    price: [PaymentOrderConnectionPrice]
    shippingAddress: [PaymentOrderConnectionShippingAddress]
    status: [PaymentOrderConnectionStatus]
    updated_at: [PaymentOrderConnectionUpdated_at]
    user: [PaymentOrderConnectionUser]
    uuid: [PaymentOrderConnectionUuid]
}

type PaymentOrderItem {
    additional: JSON
    created_at: DateTime!
    currency: PaymentCurrency
    id: ID!
    name: String!
    order: PaymentOrder
    picture: UploadFile
    preUnitPrice: Float
    quantity: Int!
    related: Morph
    sourceId: String
    sourceType: String
    unitPrice: Float
    updated_at: DateTime!
}

type PaymentPolicy {
    created_at: DateTime!
    id: ID!
    policy: String
    updated_at: DateTime!
}

type PaymentSetting {
    created_at: DateTime!
    data: JSON
    id: ID!
    updated_at: DateTime!
    user: UsersPermissionsUser
}

type Plan {
    articles(limit: Int, sort: String, start: Int, where: JSON): [Article]
    assessment(limit: Int, sort: String, start: Int, where: JSON): [AssessmentQuestionnaire]
    books(limit: Int, sort: String, start: Int, where: JSON): [Book]
    content: String
    created_at: DateTime!
    exercises(limit: Int, sort: String, start: Int, where: JSON): [Exercise]
    forPerson: ComponentDataFor
    id: ID!
    name: String!
    parentings(limit: Int, sort: String, start: Int, where: JSON): [Parenting]
    post: ComponentContentPost
    questionnaire: Questionnaire
    supplements(limit: Int, sort: String, start: Int, where: JSON): [Supplement]
    updated_at: DateTime!
}

type PlanAggregator {
    count: Int
    totalCount: Int
}

type PlanConnection {
    aggregate: PlanAggregator
    groupBy: PlanGroupBy
    values: [Plan]
}

type PlanConnectionContent {
    connection: PlanConnection
    key: String
}

type PlanConnectionCreated_at {
    connection: PlanConnection
    key: DateTime
}

type PlanConnectionForPerson {
    connection: PlanConnection
    key: ID
}

type PlanConnectionId {
    connection: PlanConnection
    key: ID
}

type PlanConnectionName {
    connection: PlanConnection
    key: String
}

type PlanConnectionPost {
    connection: PlanConnection
    key: ID
}

type PlanConnectionQuestionnaire {
    connection: PlanConnection
    key: ID
}

type PlanConnectionUpdated_at {
    connection: PlanConnection
    key: DateTime
}

type PlanGroupBy {
    content: [PlanConnectionContent]
    created_at: [PlanConnectionCreated_at]
    forPerson: [PlanConnectionForPerson]
    id: [PlanConnectionId]
    name: [PlanConnectionName]
    post: [PlanConnectionPost]
    questionnaire: [PlanConnectionQuestionnaire]
    updated_at: [PlanConnectionUpdated_at]
}

type Post {
    author: UsersPermissionsUser
    categories(limit: Int, sort: String, start: Int, where: JSON): [Category]
    cover_background_color: Color
    created_at: DateTime!
    currency: PaymentCurrency
    entityRawId: String
    entityType: String
    id: ID!
    image(limit: Int, sort: String, start: Int, where: JSON): [UploadFile]
    needShipping: Boolean
    prePrice: Float
    price: Float
    published_at: DateTime
    rating: Int
    rawPostId: Int
    recommended: Boolean
    status: PosterStatus
    subtitle: String
    title: String!
    trademark: Trademark
    updated_at: DateTime!
    updated_day: Date
    vipText: String
    vip_color: Color
}

type PostAggregator {
    avg: PostAggregatorAvg
    count: Int
    max: PostAggregatorMax
    min: PostAggregatorMin
    sum: PostAggregatorSum
    totalCount: Int
}

type PostAggregatorAvg {
    prePrice: Float
    price: Float
    rating: Float
    rawPostId: Float
}

type PostAggregatorMax {
    prePrice: Float
    price: Float
    rating: Float
    rawPostId: Float
}

type PostAggregatorMin {
    prePrice: Float
    price: Float
    rating: Float
    rawPostId: Float
}

type PostAggregatorSum {
    prePrice: Float
    price: Float
    rating: Float
    rawPostId: Float
}

type PostConnection {
    aggregate: PostAggregator
    groupBy: PostGroupBy
    values: [Post]
}

type PostConnectionAuthor {
    connection: PostConnection
    key: ID
}

type PostConnectionCover_background_color {
    connection: PostConnection
    key: ID
}

type PostConnectionCreated_at {
    connection: PostConnection
    key: DateTime
}

type PostConnectionCurrency {
    connection: PostConnection
    key: ID
}

type PostConnectionEntityRawId {
    connection: PostConnection
    key: String
}

type PostConnectionEntityType {
    connection: PostConnection
    key: String
}

type PostConnectionId {
    connection: PostConnection
    key: ID
}

type PostConnectionNeedShipping {
    connection: PostConnection
    key: Boolean
}

type PostConnectionPrePrice {
    connection: PostConnection
    key: Float
}

type PostConnectionPrice {
    connection: PostConnection
    key: Float
}

type PostConnectionPublished_at {
    connection: PostConnection
    key: DateTime
}

type PostConnectionRating {
    connection: PostConnection
    key: Int
}

type PostConnectionRawPostId {
    connection: PostConnection
    key: Int
}

type PostConnectionRecommended {
    connection: PostConnection
    key: Boolean
}

type PostConnectionStatus {
    connection: PostConnection
    key: String
}

type PostConnectionSubtitle {
    connection: PostConnection
    key: String
}

type PostConnectionTitle {
    connection: PostConnection
    key: String
}

type PostConnectionTrademark {
    connection: PostConnection
    key: ID
}

type PostConnectionUpdated_at {
    connection: PostConnection
    key: DateTime
}

type PostConnectionUpdated_day {
    connection: PostConnection
    key: ID
}

type PostConnectionVipText {
    connection: PostConnection
    key: String
}

type PostConnectionVip_color {
    connection: PostConnection
    key: ID
}

type PostGroupBy {
    author: [PostConnectionAuthor]
    cover_background_color: [PostConnectionCover_background_color]
    created_at: [PostConnectionCreated_at]
    currency: [PostConnectionCurrency]
    entityRawId: [PostConnectionEntityRawId]
    entityType: [PostConnectionEntityType]
    id: [PostConnectionId]
    needShipping: [PostConnectionNeedShipping]
    prePrice: [PostConnectionPrePrice]
    price: [PostConnectionPrice]
    published_at: [PostConnectionPublished_at]
    rating: [PostConnectionRating]
    rawPostId: [PostConnectionRawPostId]
    recommended: [PostConnectionRecommended]
    status: [PostConnectionStatus]
    subtitle: [PostConnectionSubtitle]
    title: [PostConnectionTitle]
    trademark: [PostConnectionTrademark]
    updated_at: [PostConnectionUpdated_at]
    updated_day: [PostConnectionUpdated_day]
    vipText: [PostConnectionVipText]
    vip_color: [PostConnectionVip_color]
}

type Provider {
    address: String
    content: String
    created_at: DateTime!
    email: String
    id: ID!
    name: String
    phoneNumber: String
    trademark: UploadFile
    updated_at: DateTime!
}

type ProviderAggregator {
    count: Int
    totalCount: Int
}

type ProviderConnection {
    aggregate: ProviderAggregator
    groupBy: ProviderGroupBy
    values: [Provider]
}

type ProviderConnectionAddress {
    connection: ProviderConnection
    key: String
}

type ProviderConnectionContent {
    connection: ProviderConnection
    key: String
}

type ProviderConnectionCreated_at {
    connection: ProviderConnection
    key: DateTime
}

type ProviderConnectionEmail {
    connection: ProviderConnection
    key: String
}

type ProviderConnectionId {
    connection: ProviderConnection
    key: ID
}

type ProviderConnectionName {
    connection: ProviderConnection
    key: String
}

type ProviderConnectionPhoneNumber {
    connection: ProviderConnection
    key: String
}

type ProviderConnectionTrademark {
    connection: ProviderConnection
    key: ID
}

type ProviderConnectionUpdated_at {
    connection: ProviderConnection
    key: DateTime
}

type ProviderGroupBy {
    address: [ProviderConnectionAddress]
    content: [ProviderConnectionContent]
    created_at: [ProviderConnectionCreated_at]
    email: [ProviderConnectionEmail]
    id: [ProviderConnectionId]
    name: [ProviderConnectionName]
    phoneNumber: [ProviderConnectionPhoneNumber]
    trademark: [ProviderConnectionTrademark]
    updated_at: [ProviderConnectionUpdated_at]
}

type Query {
    aboutFastBraiin(publicationState: PublicationState): AboutFastBraiin
    account(id: ID!, publicationState: PublicationState): Account
    accounts(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Account]
    accountsConnection(limit: Int, sort: String, start: Int, where: JSON): AccountConnection
    appTermOfService(publicationState: PublicationState): AppTermOfService
    article(id: ID!, publicationState: PublicationState): Article
    articles(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Article]
    articlesConnection(limit: Int, sort: String, start: Int, where: JSON): ArticleConnection
    assessmentQuestionnaire(id: ID!, publicationState: PublicationState): AssessmentQuestionnaire
    assessmentQuestionnaires(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [AssessmentQuestionnaire]
    assessmentQuestionnairesConnection(limit: Int, sort: String, start: Int, where: JSON): AssessmentQuestionnaireConnection
    assessmentTermOfService(publicationState: PublicationState): AssessmentTermOfService
    book(id: ID!, publicationState: PublicationState): Book
    books(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Book]
    booksConnection(limit: Int, sort: String, start: Int, where: JSON): BookConnection
    categories(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Category]
    categoriesConnection(limit: Int, sort: String, start: Int, where: JSON): CategoryConnection
    category(id: ID!, publicationState: PublicationState): Category
    classification(id: ID!, publicationState: PublicationState): Classification
    classifications(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Classification]
    classificationsConnection(limit: Int, sort: String, start: Int, where: JSON): ClassificationConnection
    color(id: ID!, publicationState: PublicationState): Color
    colors(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Color]
    colorsConnection(limit: Int, sort: String, start: Int, where: JSON): ColorConnection
    course(id: ID!, publicationState: PublicationState): Course
    courses(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Course]
    coursesConnection(limit: Int, sort: String, start: Int, where: JSON): CourseConnection
    creditCard(id: ID!, publicationState: PublicationState): CreditCard
    creditCards(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [CreditCard]
    creditCardsConnection(limit: Int, sort: String, start: Int, where: JSON): CreditCardConnection
    currencies(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [PaymentCurrency]
    currenciesConnection(limit: Int, sort: String, start: Int, where: JSON): PaymentCurrencyConnection
    currency(id: ID!, publicationState: PublicationState): PaymentCurrency
    ehr(id: ID!, publicationState: PublicationState): Ehr
    ehrs(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Ehr]
    ehrsConnection(limit: Int, sort: String, start: Int, where: JSON): EhrConnection
    event(id: ID!, publicationState: PublicationState): Event
    events(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Event]
    eventsConnection(limit: Int, sort: String, start: Int, where: JSON): EventConnection
    exercise(id: ID!, publicationState: PublicationState): Exercise
    exercises(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Exercise]
    exercisesConnection(limit: Int, sort: String, start: Int, where: JSON): ExerciseConnection
    files(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [UploadFile]
    filesConnection(limit: Int, sort: String, start: Int, where: JSON): UploadFileConnection
    findMyAddress(limit: Int, sort: String, start: Int, where: JSON): [UserAddress]
    game(id: ID!, publicationState: PublicationState): Game
    games(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Game]
    gamesConnection(limit: Int, sort: String, start: Int, where: JSON): GameConnection
    location(id: ID!, publicationState: PublicationState): Location
    locations(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Location]
    locationsConnection(limit: Int, sort: String, start: Int, where: JSON): LocationConnection
    me: UsersPermissionsMe
    myChild(id: ID!): UsersPermissionsUser
    myOrders(limit: Int, sort: String, start: Int, where: JSON): [PaymentOrder]
    myOrdersCount(where: JSON): Int!
    order(id: ID!, publicationState: PublicationState): PaymentOrder
    orders(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [PaymentOrder]
    ordersConnection(limit: Int, sort: String, start: Int, where: JSON): PaymentOrderConnection
    organizationUnit(id: ID!, publicationState: PublicationState): UsersOrganizationunitsOrganizationUnit
    organizationUnits(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [UsersOrganizationunitsOrganizationUnit]
    organizationUnitsConnection(limit: Int, sort: String, start: Int, where: JSON): UsersOrganizationunitsOrganizationUnitConnection
    parenting(id: ID!, publicationState: PublicationState): Parenting
    parentings(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Parenting]
    parentingsConnection(limit: Int, sort: String, start: Int, where: JSON): ParentingConnection
    patient(id: ID!, publicationState: PublicationState): Patient
    patients(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Patient]
    patientsConnection(limit: Int, sort: String, start: Int, where: JSON): PatientConnection
    paymentMethod(id: ID!, publicationState: PublicationState): PaymentMethod
    paymentMethods(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [PaymentMethod]
    paymentMethodsConnection(limit: Int, sort: String, start: Int, where: JSON): PaymentMethodConnection
    paymentPolicy(publicationState: PublicationState): PaymentPolicy
    plan(id: ID!, publicationState: PublicationState): Plan
    plans(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Plan]
    plansConnection(limit: Int, sort: String, start: Int, where: JSON): PlanConnection
    post(id: ID!, publicationState: PublicationState): Post
    posts(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Post]
    postsConnection(limit: Int, sort: String, start: Int, where: JSON): PostConnection
    provider(id: ID!, publicationState: PublicationState): Provider
    providers(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Provider]
    providersConnection(limit: Int, sort: String, start: Int, where: JSON): ProviderConnection
    questionnaire(id: ID!, publicationState: PublicationState): Questionnaire
    questionnaireAnswer(id: ID!, publicationState: PublicationState): QuestionnaireAnswer
    questionnaireAnswers(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [QuestionnaireAnswer]
    questionnaireAnswersConnection(limit: Int, sort: String, start: Int, where: JSON): QuestionnaireAnswerConnection
    questionnaires(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Questionnaire]
    questionnairesConnection(limit: Int, sort: String, start: Int, where: JSON): QuestionnaireConnection
    reminder(id: ID!, publicationState: PublicationState): Reminder
    reminders(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Reminder]
    remindersConnection(limit: Int, sort: String, start: Int, where: JSON): ReminderConnection
    role(id: ID!, publicationState: PublicationState): UsersPermissionsRole
    "Retrieve all the existing roles. You can't apply filters on this query."
    roles(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [UsersPermissionsRole]
    rolesConnection(limit: Int, sort: String, start: Int, where: JSON): UsersPermissionsRoleConnection
    school(id: ID!, publicationState: PublicationState): School
    schools(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [School]
    schoolsConnection(limit: Int, sort: String, start: Int, where: JSON): SchoolConnection
    supplement(id: ID!, publicationState: PublicationState): Supplement
    supplements(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Supplement]
    supplementsConnection(limit: Int, sort: String, start: Int, where: JSON): SupplementConnection
    telemetries(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Telemetry]
    telemetriesConnection(limit: Int, sort: String, start: Int, where: JSON): TelemetryConnection
    telemetry(id: ID!, publicationState: PublicationState): Telemetry
    trademark(id: ID!, publicationState: PublicationState): Trademark
    trademarks(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Trademark]
    trademarksConnection(limit: Int, sort: String, start: Int, where: JSON): TrademarkConnection
    user(id: ID!, publicationState: PublicationState): UsersPermissionsUser
    userAddress(id: ID!, publicationState: PublicationState): UserAddress
    userAddresses(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [UserAddress]
    userAddressesConnection(limit: Int, sort: String, start: Int, where: JSON): UserAddressConnection
    userAgreement(id: ID!, publicationState: PublicationState): UserAgreement
    userAgreements(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [UserAgreement]
    userAgreementsConnection(limit: Int, sort: String, start: Int, where: JSON): UserAgreementConnection
    userAssessment(id: ID!, publicationState: PublicationState): UserAssessment
    userAssessments(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [UserAssessment]
    userAssessmentsConnection(limit: Int, sort: String, start: Int, where: JSON): UserAssessmentConnection
    userExercise(id: ID!, publicationState: PublicationState): UserExercise
    userExercises(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [UserExercise]
    userExercisesConnection(limit: Int, sort: String, start: Int, where: JSON): UserExerciseConnection
    userParenting(id: ID!, publicationState: PublicationState): UserParenting
    userParentings(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [UserParenting]
    userParentingsConnection(limit: Int, sort: String, start: Int, where: JSON): UserParentingConnection
    userPlan(id: ID!, publicationState: PublicationState): UserPlan
    userPlans(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [UserPlan]
    userPlansConnection(limit: Int, sort: String, start: Int, where: JSON): UserPlanConnection
    users(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [UsersPermissionsUser]
    usersConnection(limit: Int, sort: String, start: Int, where: JSON): UsersPermissionsUserConnection
    venue(id: ID!, publicationState: PublicationState): Venue
    venues(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Venue]
    venuesConnection(limit: Int, sort: String, start: Int, where: JSON): VenueConnection
    version(publicationState: PublicationState): Version
    webinar(id: ID!, publicationState: PublicationState): Webinar
    webinars(limit: Int, publicationState: PublicationState, sort: String, start: Int, where: JSON): [Webinar]
    webinarsConnection(limit: Int, sort: String, start: Int, where: JSON): WebinarConnection
}

type Questionnaire {
    assessment_questionnaires(limit: Int, sort: String, start: Int, where: JSON): [AssessmentQuestionnaire]
    created_at: DateTime!
    data: String
    displayName: String
    id: ID!
    name: String!
    provider: String
    updated_at: DateTime!
}

type QuestionnaireAggregator {
    count: Int
    totalCount: Int
}

type QuestionnaireAnswer {
    created_at: DateTime!
    data: JSON
    id: ID!
    name: String!
    questionnaire: Questionnaire
    submitted: Boolean!
    updated_at: DateTime!
    user: UsersPermissionsUser
}

type QuestionnaireAnswerAggregator {
    count: Int
    totalCount: Int
}

type QuestionnaireAnswerConnection {
    aggregate: QuestionnaireAnswerAggregator
    groupBy: QuestionnaireAnswerGroupBy
    values: [QuestionnaireAnswer]
}

type QuestionnaireAnswerConnectionCreated_at {
    connection: QuestionnaireAnswerConnection
    key: DateTime
}

type QuestionnaireAnswerConnectionData {
    connection: QuestionnaireAnswerConnection
    key: JSON
}

type QuestionnaireAnswerConnectionId {
    connection: QuestionnaireAnswerConnection
    key: ID
}

type QuestionnaireAnswerConnectionName {
    connection: QuestionnaireAnswerConnection
    key: String
}

type QuestionnaireAnswerConnectionQuestionnaire {
    connection: QuestionnaireAnswerConnection
    key: ID
}

type QuestionnaireAnswerConnectionSubmitted {
    connection: QuestionnaireAnswerConnection
    key: Boolean
}

type QuestionnaireAnswerConnectionUpdated_at {
    connection: QuestionnaireAnswerConnection
    key: DateTime
}

type QuestionnaireAnswerConnectionUser {
    connection: QuestionnaireAnswerConnection
    key: ID
}

type QuestionnaireAnswerGroupBy {
    created_at: [QuestionnaireAnswerConnectionCreated_at]
    data: [QuestionnaireAnswerConnectionData]
    id: [QuestionnaireAnswerConnectionId]
    name: [QuestionnaireAnswerConnectionName]
    questionnaire: [QuestionnaireAnswerConnectionQuestionnaire]
    submitted: [QuestionnaireAnswerConnectionSubmitted]
    updated_at: [QuestionnaireAnswerConnectionUpdated_at]
    user: [QuestionnaireAnswerConnectionUser]
}

type QuestionnaireConnection {
    aggregate: QuestionnaireAggregator
    groupBy: QuestionnaireGroupBy
    values: [Questionnaire]
}

type QuestionnaireConnectionCreated_at {
    connection: QuestionnaireConnection
    key: DateTime
}

type QuestionnaireConnectionData {
    connection: QuestionnaireConnection
    key: String
}

type QuestionnaireConnectionDisplayName {
    connection: QuestionnaireConnection
    key: String
}

type QuestionnaireConnectionId {
    connection: QuestionnaireConnection
    key: ID
}

type QuestionnaireConnectionName {
    connection: QuestionnaireConnection
    key: String
}

type QuestionnaireConnectionProvider {
    connection: QuestionnaireConnection
    key: String
}

type QuestionnaireConnectionUpdated_at {
    connection: QuestionnaireConnection
    key: DateTime
}

type QuestionnaireGroupBy {
    created_at: [QuestionnaireConnectionCreated_at]
    data: [QuestionnaireConnectionData]
    displayName: [QuestionnaireConnectionDisplayName]
    id: [QuestionnaireConnectionId]
    name: [QuestionnaireConnectionName]
    provider: [QuestionnaireConnectionProvider]
    updated_at: [QuestionnaireConnectionUpdated_at]
}

type Reminder {
    body: String
    created_at: DateTime!
    dateTime: DateTime
    id: ID!
    name: String!
    related(limit: Int, sort: String, start: Int, where: JSON): [Morph]
    source: String
    sourceId: String
    type: ReminderType!
    updated_at: DateTime!
    user: UsersPermissionsUser
}

type ReminderAggregator {
    count: Int
    totalCount: Int
}

type ReminderConnection {
    aggregate: ReminderAggregator
    groupBy: ReminderGroupBy
    values: [Reminder]
}

type ReminderConnectionBody {
    connection: ReminderConnection
    key: String
}

type ReminderConnectionCreated_at {
    connection: ReminderConnection
    key: DateTime
}

type ReminderConnectionDateTime {
    connection: ReminderConnection
    key: DateTime
}

type ReminderConnectionId {
    connection: ReminderConnection
    key: ID
}

type ReminderConnectionName {
    connection: ReminderConnection
    key: String
}

type ReminderConnectionSource {
    connection: ReminderConnection
    key: String
}

type ReminderConnectionSourceId {
    connection: ReminderConnection
    key: String
}

type ReminderConnectionType {
    connection: ReminderConnection
    key: String
}

type ReminderConnectionUpdated_at {
    connection: ReminderConnection
    key: DateTime
}

type ReminderConnectionUser {
    connection: ReminderConnection
    key: ID
}

type ReminderGroupBy {
    body: [ReminderConnectionBody]
    created_at: [ReminderConnectionCreated_at]
    dateTime: [ReminderConnectionDateTime]
    id: [ReminderConnectionId]
    name: [ReminderConnectionName]
    source: [ReminderConnectionSource]
    sourceId: [ReminderConnectionSourceId]
    type: [ReminderConnectionType]
    updated_at: [ReminderConnectionUpdated_at]
    user: [ReminderConnectionUser]
}

type School {
    address: String
    created_at: DateTime!
    email: String
    id: ID!
    name: String!
    phone: String
    picture: UploadFile
    teachers(limit: Int, sort: String, start: Int, where: JSON): [UsersPermissionsUser]
    type: SchoolType!
    updated_at: DateTime!
}

type SchoolAggregator {
    count: Int
    totalCount: Int
}

type SchoolConnection {
    aggregate: SchoolAggregator
    groupBy: SchoolGroupBy
    values: [School]
}

type SchoolConnectionAddress {
    connection: SchoolConnection
    key: String
}

type SchoolConnectionCreated_at {
    connection: SchoolConnection
    key: DateTime
}

type SchoolConnectionEmail {
    connection: SchoolConnection
    key: String
}

type SchoolConnectionId {
    connection: SchoolConnection
    key: ID
}

type SchoolConnectionName {
    connection: SchoolConnection
    key: String
}

type SchoolConnectionPhone {
    connection: SchoolConnection
    key: String
}

type SchoolConnectionPicture {
    connection: SchoolConnection
    key: ID
}

type SchoolConnectionType {
    connection: SchoolConnection
    key: String
}

type SchoolConnectionUpdated_at {
    connection: SchoolConnection
    key: DateTime
}

type SchoolGroupBy {
    address: [SchoolConnectionAddress]
    created_at: [SchoolConnectionCreated_at]
    email: [SchoolConnectionEmail]
    id: [SchoolConnectionId]
    name: [SchoolConnectionName]
    phone: [SchoolConnectionPhone]
    picture: [SchoolConnectionPicture]
    type: [SchoolConnectionType]
    updated_at: [SchoolConnectionUpdated_at]
}

type Supplement {
    content: String
    created_at: DateTime!
    forPerson: ComponentDataFor
    id: ID!
    name: String!
    post: ComponentContentPost
    product: ComponentContentProduct
    subject: ComponentDataEhrSubject
    updated_at: DateTime!
}

type SupplementAggregator {
    count: Int
    totalCount: Int
}

type SupplementConnection {
    aggregate: SupplementAggregator
    groupBy: SupplementGroupBy
    values: [Supplement]
}

type SupplementConnectionContent {
    connection: SupplementConnection
    key: String
}

type SupplementConnectionCreated_at {
    connection: SupplementConnection
    key: DateTime
}

type SupplementConnectionForPerson {
    connection: SupplementConnection
    key: ID
}

type SupplementConnectionId {
    connection: SupplementConnection
    key: ID
}

type SupplementConnectionName {
    connection: SupplementConnection
    key: String
}

type SupplementConnectionPost {
    connection: SupplementConnection
    key: ID
}

type SupplementConnectionProduct {
    connection: SupplementConnection
    key: ID
}

type SupplementConnectionSubject {
    connection: SupplementConnection
    key: ID
}

type SupplementConnectionUpdated_at {
    connection: SupplementConnection
    key: DateTime
}

type SupplementGroupBy {
    content: [SupplementConnectionContent]
    created_at: [SupplementConnectionCreated_at]
    forPerson: [SupplementConnectionForPerson]
    id: [SupplementConnectionId]
    name: [SupplementConnectionName]
    post: [SupplementConnectionPost]
    product: [SupplementConnectionProduct]
    subject: [SupplementConnectionSubject]
    updated_at: [SupplementConnectionUpdated_at]
}

type Telemetry {
    created_at: DateTime!
    id: ID!
    raw: JSON
    updated_at: DateTime!
}

type TelemetryAggregator {
    count: Int
    totalCount: Int
}

type TelemetryConnection {
    aggregate: TelemetryAggregator
    groupBy: TelemetryGroupBy
    values: [Telemetry]
}

type TelemetryConnectionCreated_at {
    connection: TelemetryConnection
    key: DateTime
}

type TelemetryConnectionId {
    connection: TelemetryConnection
    key: ID
}

type TelemetryConnectionRaw {
    connection: TelemetryConnection
    key: JSON
}

type TelemetryConnectionUpdated_at {
    connection: TelemetryConnection
    key: DateTime
}

type TelemetryGroupBy {
    created_at: [TelemetryConnectionCreated_at]
    id: [TelemetryConnectionId]
    raw: [TelemetryConnectionRaw]
    updated_at: [TelemetryConnectionUpdated_at]
}

type Trademark {
    created_at: DateTime!
    id: ID!
    image: UploadFile
    name: String!
    updated_at: DateTime!
}

type TrademarkAggregator {
    count: Int
    totalCount: Int
}

type TrademarkConnection {
    aggregate: TrademarkAggregator
    groupBy: TrademarkGroupBy
    values: [Trademark]
}

type TrademarkConnectionCreated_at {
    connection: TrademarkConnection
    key: DateTime
}

type TrademarkConnectionId {
    connection: TrademarkConnection
    key: ID
}

type TrademarkConnectionImage {
    connection: TrademarkConnection
    key: ID
}

type TrademarkConnectionName {
    connection: TrademarkConnection
    key: String
}

type TrademarkConnectionUpdated_at {
    connection: TrademarkConnection
    key: DateTime
}

type TrademarkGroupBy {
    created_at: [TrademarkConnectionCreated_at]
    id: [TrademarkConnectionId]
    image: [TrademarkConnectionImage]
    name: [TrademarkConnectionName]
    updated_at: [TrademarkConnectionUpdated_at]
}

type UploadFile {
    alternativeText: String
    caption: String
    created_at: DateTime!
    ext: String
    formats: JSON
    hash: String!
    height: Int
    id: ID!
    mime: String!
    name: String!
    previewUrl: String
    provider: String!
    provider_metadata: JSON
    related(limit: Int, sort: String, start: Int, where: JSON): [Morph]
    size: Float!
    updated_at: DateTime!
    url: String!
    width: Int
}

type UploadFileAggregator {
    avg: UploadFileAggregatorAvg
    count: Int
    max: UploadFileAggregatorMax
    min: UploadFileAggregatorMin
    sum: UploadFileAggregatorSum
    totalCount: Int
}

type UploadFileAggregatorAvg {
    height: Float
    size: Float
    width: Float
}

type UploadFileAggregatorMax {
    height: Float
    size: Float
    width: Float
}

type UploadFileAggregatorMin {
    height: Float
    size: Float
    width: Float
}

type UploadFileAggregatorSum {
    height: Float
    size: Float
    width: Float
}

type UploadFileConnection {
    aggregate: UploadFileAggregator
    groupBy: UploadFileGroupBy
    values: [UploadFile]
}

type UploadFileConnectionAlternativeText {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionCaption {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionCreated_at {
    connection: UploadFileConnection
    key: DateTime
}

type UploadFileConnectionExt {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionFormats {
    connection: UploadFileConnection
    key: JSON
}

type UploadFileConnectionHash {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionHeight {
    connection: UploadFileConnection
    key: Int
}

type UploadFileConnectionId {
    connection: UploadFileConnection
    key: ID
}

type UploadFileConnectionMime {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionName {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionPreviewUrl {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionProvider {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionProvider_metadata {
    connection: UploadFileConnection
    key: JSON
}

type UploadFileConnectionSize {
    connection: UploadFileConnection
    key: Float
}

type UploadFileConnectionUpdated_at {
    connection: UploadFileConnection
    key: DateTime
}

type UploadFileConnectionUrl {
    connection: UploadFileConnection
    key: String
}

type UploadFileConnectionWidth {
    connection: UploadFileConnection
    key: Int
}

type UploadFileGroupBy {
    alternativeText: [UploadFileConnectionAlternativeText]
    caption: [UploadFileConnectionCaption]
    created_at: [UploadFileConnectionCreated_at]
    ext: [UploadFileConnectionExt]
    formats: [UploadFileConnectionFormats]
    hash: [UploadFileConnectionHash]
    height: [UploadFileConnectionHeight]
    id: [UploadFileConnectionId]
    mime: [UploadFileConnectionMime]
    name: [UploadFileConnectionName]
    previewUrl: [UploadFileConnectionPreviewUrl]
    provider: [UploadFileConnectionProvider]
    provider_metadata: [UploadFileConnectionProvider_metadata]
    size: [UploadFileConnectionSize]
    updated_at: [UploadFileConnectionUpdated_at]
    url: [UploadFileConnectionUrl]
    width: [UploadFileConnectionWidth]
}

type UserAddress {
    address: ComponentDataAddress
    created_at: DateTime!
    id: ID!
    tag: String
    updated_at: DateTime!
    user: UsersPermissionsUser
}

type UserAddressAggregator {
    count: Int
    totalCount: Int
}

type UserAddressConnection {
    aggregate: UserAddressAggregator
    groupBy: UserAddressGroupBy
    values: [UserAddress]
}

type UserAddressConnectionAddress {
    connection: UserAddressConnection
    key: ID
}

type UserAddressConnectionCreated_at {
    connection: UserAddressConnection
    key: DateTime
}

type UserAddressConnectionId {
    connection: UserAddressConnection
    key: ID
}

type UserAddressConnectionTag {
    connection: UserAddressConnection
    key: String
}

type UserAddressConnectionUpdated_at {
    connection: UserAddressConnection
    key: DateTime
}

type UserAddressConnectionUser {
    connection: UserAddressConnection
    key: ID
}

type UserAddressGroupBy {
    address: [UserAddressConnectionAddress]
    created_at: [UserAddressConnectionCreated_at]
    id: [UserAddressConnectionId]
    tag: [UserAddressConnectionTag]
    updated_at: [UserAddressConnectionUpdated_at]
    user: [UserAddressConnectionUser]
}

type UserAgreement {
    content: String!
    created_at: DateTime!
    id: ID!
    lastVersionDate: DateTime!
    termOfServiceType: TermOfServiceType!
    updated_at: DateTime!
    user: UsersPermissionsUser
    value: Boolean
}

type UserAgreementAggregator {
    count: Int
    totalCount: Int
}

type UserAgreementConnection {
    aggregate: UserAgreementAggregator
    groupBy: UserAgreementGroupBy
    values: [UserAgreement]
}

type UserAgreementConnectionContent {
    connection: UserAgreementConnection
    key: String
}

type UserAgreementConnectionCreated_at {
    connection: UserAgreementConnection
    key: DateTime
}

type UserAgreementConnectionId {
    connection: UserAgreementConnection
    key: ID
}

type UserAgreementConnectionLastVersionDate {
    connection: UserAgreementConnection
    key: DateTime
}

type UserAgreementConnectionTermOfServiceType {
    connection: UserAgreementConnection
    key: String
}

type UserAgreementConnectionUpdated_at {
    connection: UserAgreementConnection
    key: DateTime
}

type UserAgreementConnectionUser {
    connection: UserAgreementConnection
    key: ID
}

type UserAgreementConnectionValue {
    connection: UserAgreementConnection
    key: Boolean
}

type UserAgreementGroupBy {
    content: [UserAgreementConnectionContent]
    created_at: [UserAgreementConnectionCreated_at]
    id: [UserAgreementConnectionId]
    lastVersionDate: [UserAgreementConnectionLastVersionDate]
    termOfServiceType: [UserAgreementConnectionTermOfServiceType]
    updated_at: [UserAgreementConnectionUpdated_at]
    user: [UserAgreementConnectionUser]
    value: [UserAgreementConnectionValue]
}

type UserAssessment {
    assessment_questionnaire: AssessmentQuestionnaire
    created_at: DateTime!
    id: ID!
    updated_at: DateTime!
    user: UsersPermissionsUser
}

type UserAssessmentAggregator {
    count: Int
    totalCount: Int
}

type UserAssessmentConnection {
    aggregate: UserAssessmentAggregator
    groupBy: UserAssessmentGroupBy
    values: [UserAssessment]
}

type UserAssessmentConnectionAssessment_questionnaire {
    connection: UserAssessmentConnection
    key: ID
}

type UserAssessmentConnectionCreated_at {
    connection: UserAssessmentConnection
    key: DateTime
}

type UserAssessmentConnectionId {
    connection: UserAssessmentConnection
    key: ID
}

type UserAssessmentConnectionUpdated_at {
    connection: UserAssessmentConnection
    key: DateTime
}

type UserAssessmentConnectionUser {
    connection: UserAssessmentConnection
    key: ID
}

type UserAssessmentGroupBy {
    assessment_questionnaire: [UserAssessmentConnectionAssessment_questionnaire]
    created_at: [UserAssessmentConnectionCreated_at]
    id: [UserAssessmentConnectionId]
    updated_at: [UserAssessmentConnectionUpdated_at]
    user: [UserAssessmentConnectionUser]
}

type UserExercise {
    created_at: DateTime!
    exercise: Exercise
    id: ID!
    updated_at: DateTime!
    user: UsersPermissionsUser
}

type UserExerciseAggregator {
    count: Int
    totalCount: Int
}

type UserExerciseConnection {
    aggregate: UserExerciseAggregator
    groupBy: UserExerciseGroupBy
    values: [UserExercise]
}

type UserExerciseConnectionCreated_at {
    connection: UserExerciseConnection
    key: DateTime
}

type UserExerciseConnectionExercise {
    connection: UserExerciseConnection
    key: ID
}

type UserExerciseConnectionId {
    connection: UserExerciseConnection
    key: ID
}

type UserExerciseConnectionUpdated_at {
    connection: UserExerciseConnection
    key: DateTime
}

type UserExerciseConnectionUser {
    connection: UserExerciseConnection
    key: ID
}

type UserExerciseGroupBy {
    created_at: [UserExerciseConnectionCreated_at]
    exercise: [UserExerciseConnectionExercise]
    id: [UserExerciseConnectionId]
    updated_at: [UserExerciseConnectionUpdated_at]
    user: [UserExerciseConnectionUser]
}

type UserParenting {
    created_at: DateTime!
    id: ID!
    parenting: Parenting
    updated_at: DateTime!
    user: UsersPermissionsUser
}

type UserParentingAggregator {
    count: Int
    totalCount: Int
}

type UserParentingConnection {
    aggregate: UserParentingAggregator
    groupBy: UserParentingGroupBy
    values: [UserParenting]
}

type UserParentingConnectionCreated_at {
    connection: UserParentingConnection
    key: DateTime
}

type UserParentingConnectionId {
    connection: UserParentingConnection
    key: ID
}

type UserParentingConnectionParenting {
    connection: UserParentingConnection
    key: ID
}

type UserParentingConnectionUpdated_at {
    connection: UserParentingConnection
    key: DateTime
}

type UserParentingConnectionUser {
    connection: UserParentingConnection
    key: ID
}

type UserParentingGroupBy {
    created_at: [UserParentingConnectionCreated_at]
    id: [UserParentingConnectionId]
    parenting: [UserParentingConnectionParenting]
    updated_at: [UserParentingConnectionUpdated_at]
    user: [UserParentingConnectionUser]
}

type UserPermissionsPasswordPayload {
    ok: Boolean!
}

type UserPlan {
    created_at: DateTime!
    id: ID!
    parentings(limit: Int, sort: String, start: Int, where: JSON): [Parenting]
    status: PlanStatus!
    updated_at: DateTime!
    user: UsersPermissionsUser
    user_assessments(limit: Int, sort: String, start: Int, where: JSON): [UserAssessment]
    user_exercises(limit: Int, sort: String, start: Int, where: JSON): [UserExercise]
}

type UserPlanAggregator {
    count: Int
    totalCount: Int
}

type UserPlanConnection {
    aggregate: UserPlanAggregator
    groupBy: UserPlanGroupBy
    values: [UserPlan]
}

type UserPlanConnectionCreated_at {
    connection: UserPlanConnection
    key: DateTime
}

type UserPlanConnectionId {
    connection: UserPlanConnection
    key: ID
}

type UserPlanConnectionStatus {
    connection: UserPlanConnection
    key: String
}

type UserPlanConnectionUpdated_at {
    connection: UserPlanConnection
    key: DateTime
}

type UserPlanConnectionUser {
    connection: UserPlanConnection
    key: ID
}

type UserPlanGroupBy {
    created_at: [UserPlanConnectionCreated_at]
    id: [UserPlanConnectionId]
    status: [UserPlanConnectionStatus]
    updated_at: [UserPlanConnectionUpdated_at]
    user: [UserPlanConnectionUser]
}

type UsersOrganizationunitsOrganizationUnit {
    children(limit: Int, sort: String, start: Int, where: JSON): [UsersOrganizationunitsOrganizationUnit]
    code: String
    created_at: DateTime!
    displayName: String!
    id: ID!
    parent: UsersOrganizationunitsOrganizationUnit
    roles(limit: Int, sort: String, start: Int, where: JSON): [UsersPermissionsRole]
    updated_at: DateTime!
    users(limit: Int, sort: String, start: Int, where: JSON): [UsersPermissionsUser]
}

type UsersOrganizationunitsOrganizationUnitAggregator {
    count: Int
    totalCount: Int
}

type UsersOrganizationunitsOrganizationUnitConnection {
    aggregate: UsersOrganizationunitsOrganizationUnitAggregator
    groupBy: UsersOrganizationunitsOrganizationUnitGroupBy
    values: [UsersOrganizationunitsOrganizationUnit]
}

type UsersOrganizationunitsOrganizationUnitConnectionCode {
    connection: UsersOrganizationunitsOrganizationUnitConnection
    key: String
}

type UsersOrganizationunitsOrganizationUnitConnectionCreated_at {
    connection: UsersOrganizationunitsOrganizationUnitConnection
    key: DateTime
}

type UsersOrganizationunitsOrganizationUnitConnectionDisplayName {
    connection: UsersOrganizationunitsOrganizationUnitConnection
    key: String
}

type UsersOrganizationunitsOrganizationUnitConnectionId {
    connection: UsersOrganizationunitsOrganizationUnitConnection
    key: ID
}

type UsersOrganizationunitsOrganizationUnitConnectionParent {
    connection: UsersOrganizationunitsOrganizationUnitConnection
    key: ID
}

type UsersOrganizationunitsOrganizationUnitConnectionUpdated_at {
    connection: UsersOrganizationunitsOrganizationUnitConnection
    key: DateTime
}

type UsersOrganizationunitsOrganizationUnitGroupBy {
    code: [UsersOrganizationunitsOrganizationUnitConnectionCode]
    created_at: [UsersOrganizationunitsOrganizationUnitConnectionCreated_at]
    displayName: [UsersOrganizationunitsOrganizationUnitConnectionDisplayName]
    id: [UsersOrganizationunitsOrganizationUnitConnectionId]
    parent: [UsersOrganizationunitsOrganizationUnitConnectionParent]
    updated_at: [UsersOrganizationunitsOrganizationUnitConnectionUpdated_at]
}

type UsersPermissionsLoginPayload {
    expire_at: DateTime
    jwt: String
    user: UsersPermissionsMe!
}

type UsersPermissionsMe {
    accountInfo: Account
    authorInfo: ComponentUserAuthor
    birthday: Date
    blocked: Boolean
    childInfo: ComponentUserChild
    confirmed: Boolean
    counselorInfo: ComponentUserCounselor
    created_at: DateTime!
    created_by: AdminUser
    doctorInfo: ComponentUserDoctor
    email: String!
    fullName: String
    id: ID!
    image: UploadFile
    name: String
    nurseInfo: ComponentUserNurse
    organization_units(limit: Int, sort: String, start: Int, where: JSON): [UsersOrganizationunitsOrganizationUnit]
    parentInfo: ComponentUserParent
    patientInfo: Patient
    phone: String
    provider: String
    qrUrl: String
    role: UsersPermissionsMeRole
    second_email: String
    sex: SexType
    status: UserStatus!
    teacherInfo: ComponentUserTeacher
    updated_at: DateTime!
    user_agreements(limit: Int, sort: String, start: Int, where: JSON): [UserAgreement]
    username: String!
}

type UsersPermissionsMeRole {
    description: String
    id: ID!
    name: String!
    type: String
}

type UsersPermissionsPermission {
    action: String!
    controller: String!
    enabled: Boolean!
    id: ID!
    policy: String
    role: UsersPermissionsRole
    type: String!
}

type UsersPermissionsRefreshTokenPayload {
    expire_at: DateTime
    jwt: String!
}

type UsersPermissionsRole {
    description: String
    id: ID!
    name: String!
    permissions(limit: Int, sort: String, start: Int, where: JSON): [UsersPermissionsPermission]
    type: String
    users(limit: Int, sort: String, start: Int, where: JSON): [UsersPermissionsUser]
}

type UsersPermissionsRoleAggregator {
    count: Int
    totalCount: Int
}

type UsersPermissionsRoleConnection {
    aggregate: UsersPermissionsRoleAggregator
    groupBy: UsersPermissionsRoleGroupBy
    values: [UsersPermissionsRole]
}

type UsersPermissionsRoleConnectionDescription {
    connection: UsersPermissionsRoleConnection
    key: String
}

type UsersPermissionsRoleConnectionId {
    connection: UsersPermissionsRoleConnection
    key: ID
}

type UsersPermissionsRoleConnectionName {
    connection: UsersPermissionsRoleConnection
    key: String
}

type UsersPermissionsRoleConnectionType {
    connection: UsersPermissionsRoleConnection
    key: String
}

type UsersPermissionsRoleGroupBy {
    description: [UsersPermissionsRoleConnectionDescription]
    id: [UsersPermissionsRoleConnectionId]
    name: [UsersPermissionsRoleConnectionName]
    type: [UsersPermissionsRoleConnectionType]
}

type UsersPermissionsUser {
    accountInfo: Account
    authorInfo: ComponentUserAuthor
    birthday: Date
    blocked: Boolean
    childInfo: ComponentUserChild
    children(limit: Int, sort: String, start: Int, where: JSON): [UsersPermissionsUser]
    confirmed: Boolean
    content: String
    counselorInfo: ComponentUserCounselor
    created_at: DateTime!
    doctorInfo: ComponentUserDoctor
    email: String
    fullName: String
    id: ID!
    image: UploadFile
    name: String
    nurseInfo: ComponentUserNurse
    organization_units(limit: Int, sort: String, start: Int, where: JSON): [UsersOrganizationunitsOrganizationUnit]
    parent: UsersPermissionsUser
    parentInfo: ComponentUserParent
    patientInfo: Patient
    phone: String
    provider: String
    qrUrl: String
    role: UsersPermissionsRole
    second_email: String
    sex: SexType
    status: UserStatus!
    teacherInfo: ComponentUserTeacher
    updated_at: DateTime!
    user_agreements(limit: Int, sort: String, start: Int, where: JSON): [UserAgreement]
    username: String!
}

type UsersPermissionsUserAggregator {
    count: Int
    totalCount: Int
}

type UsersPermissionsUserConnection {
    aggregate: UsersPermissionsUserAggregator
    groupBy: UsersPermissionsUserGroupBy
    values: [UsersPermissionsUser]
}

type UsersPermissionsUserConnectionAccountInfo {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionAuthorInfo {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionBirthday {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionBlocked {
    connection: UsersPermissionsUserConnection
    key: Boolean
}

type UsersPermissionsUserConnectionChildInfo {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionConfirmed {
    connection: UsersPermissionsUserConnection
    key: Boolean
}

type UsersPermissionsUserConnectionContent {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserConnectionCounselorInfo {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionCreated_at {
    connection: UsersPermissionsUserConnection
    key: DateTime
}

type UsersPermissionsUserConnectionDoctorInfo {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionEmail {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserConnectionFullName {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserConnectionId {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionImage {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionName {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserConnectionNurseInfo {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionParent {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionParentInfo {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionPatientInfo {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionPhone {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserConnectionProvider {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserConnectionQrUrl {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserConnectionRole {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionSecond_email {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserConnectionSex {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserConnectionStatus {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserConnectionTeacherInfo {
    connection: UsersPermissionsUserConnection
    key: ID
}

type UsersPermissionsUserConnectionUpdated_at {
    connection: UsersPermissionsUserConnection
    key: DateTime
}

type UsersPermissionsUserConnectionUsername {
    connection: UsersPermissionsUserConnection
    key: String
}

type UsersPermissionsUserGroupBy {
    accountInfo: [UsersPermissionsUserConnectionAccountInfo]
    authorInfo: [UsersPermissionsUserConnectionAuthorInfo]
    birthday: [UsersPermissionsUserConnectionBirthday]
    blocked: [UsersPermissionsUserConnectionBlocked]
    childInfo: [UsersPermissionsUserConnectionChildInfo]
    confirmed: [UsersPermissionsUserConnectionConfirmed]
    content: [UsersPermissionsUserConnectionContent]
    counselorInfo: [UsersPermissionsUserConnectionCounselorInfo]
    created_at: [UsersPermissionsUserConnectionCreated_at]
    doctorInfo: [UsersPermissionsUserConnectionDoctorInfo]
    email: [UsersPermissionsUserConnectionEmail]
    fullName: [UsersPermissionsUserConnectionFullName]
    id: [UsersPermissionsUserConnectionId]
    image: [UsersPermissionsUserConnectionImage]
    name: [UsersPermissionsUserConnectionName]
    nurseInfo: [UsersPermissionsUserConnectionNurseInfo]
    parent: [UsersPermissionsUserConnectionParent]
    parentInfo: [UsersPermissionsUserConnectionParentInfo]
    patientInfo: [UsersPermissionsUserConnectionPatientInfo]
    phone: [UsersPermissionsUserConnectionPhone]
    provider: [UsersPermissionsUserConnectionProvider]
    qrUrl: [UsersPermissionsUserConnectionQrUrl]
    role: [UsersPermissionsUserConnectionRole]
    second_email: [UsersPermissionsUserConnectionSecond_email]
    sex: [UsersPermissionsUserConnectionSex]
    status: [UsersPermissionsUserConnectionStatus]
    teacherInfo: [UsersPermissionsUserConnectionTeacherInfo]
    updated_at: [UsersPermissionsUserConnectionUpdated_at]
    username: [UsersPermissionsUserConnectionUsername]
}

type Venue {
    address: String
    capacity: Int
    contacts: String
    content: String
    created_at: DateTime!
    email: String
    id: ID!
    name: String
    phoneNumber: String
    picture: UploadFile
    post: ComponentContentPost
    updated_at: DateTime!
}

type VenueAggregator {
    avg: VenueAggregatorAvg
    count: Int
    max: VenueAggregatorMax
    min: VenueAggregatorMin
    sum: VenueAggregatorSum
    totalCount: Int
}

type VenueAggregatorAvg {
    capacity: Float
}

type VenueAggregatorMax {
    capacity: Float
}

type VenueAggregatorMin {
    capacity: Float
}

type VenueAggregatorSum {
    capacity: Float
}

type VenueConnection {
    aggregate: VenueAggregator
    groupBy: VenueGroupBy
    values: [Venue]
}

type VenueConnectionAddress {
    connection: VenueConnection
    key: String
}

type VenueConnectionCapacity {
    connection: VenueConnection
    key: Int
}

type VenueConnectionContacts {
    connection: VenueConnection
    key: String
}

type VenueConnectionContent {
    connection: VenueConnection
    key: String
}

type VenueConnectionCreated_at {
    connection: VenueConnection
    key: DateTime
}

type VenueConnectionEmail {
    connection: VenueConnection
    key: String
}

type VenueConnectionId {
    connection: VenueConnection
    key: ID
}

type VenueConnectionName {
    connection: VenueConnection
    key: String
}

type VenueConnectionPhoneNumber {
    connection: VenueConnection
    key: String
}

type VenueConnectionPicture {
    connection: VenueConnection
    key: ID
}

type VenueConnectionPost {
    connection: VenueConnection
    key: ID
}

type VenueConnectionUpdated_at {
    connection: VenueConnection
    key: DateTime
}

type VenueGroupBy {
    address: [VenueConnectionAddress]
    capacity: [VenueConnectionCapacity]
    contacts: [VenueConnectionContacts]
    content: [VenueConnectionContent]
    created_at: [VenueConnectionCreated_at]
    email: [VenueConnectionEmail]
    id: [VenueConnectionId]
    name: [VenueConnectionName]
    phoneNumber: [VenueConnectionPhoneNumber]
    picture: [VenueConnectionPicture]
    post: [VenueConnectionPost]
    updated_at: [VenueConnectionUpdated_at]
}

type Version {
    created_at: DateTime!
    description: String!
    id: ID!
    number: String!
    updated_at: DateTime!
}

type Webinar {
    content: String
    created_at: DateTime!
    id: ID!
    meetingId: String
    post: ComponentContentPost
    schedule: DateTime
    subject: ComponentDataEhrSubject
    updated_at: DateTime!
}

type WebinarAggregator {
    count: Int
    totalCount: Int
}

type WebinarConnection {
    aggregate: WebinarAggregator
    groupBy: WebinarGroupBy
    values: [Webinar]
}

type WebinarConnectionContent {
    connection: WebinarConnection
    key: String
}

type WebinarConnectionCreated_at {
    connection: WebinarConnection
    key: DateTime
}

type WebinarConnectionId {
    connection: WebinarConnection
    key: ID
}

type WebinarConnectionMeetingId {
    connection: WebinarConnection
    key: String
}

type WebinarConnectionPost {
    connection: WebinarConnection
    key: ID
}

type WebinarConnectionSchedule {
    connection: WebinarConnection
    key: DateTime
}

type WebinarConnectionSubject {
    connection: WebinarConnection
    key: ID
}

type WebinarConnectionUpdated_at {
    connection: WebinarConnection
    key: DateTime
}

type WebinarGroupBy {
    content: [WebinarConnectionContent]
    created_at: [WebinarConnectionCreated_at]
    id: [WebinarConnectionId]
    meetingId: [WebinarConnectionMeetingId]
    post: [WebinarConnectionPost]
    schedule: [WebinarConnectionSchedule]
    subject: [WebinarConnectionSubject]
    updated_at: [WebinarConnectionUpdated_at]
}

type batchTelemetryPayload {
    successCount: Int!
}

type cancelOrderPayload {
    order: PaymentOrder
}

type createAccountPayload {
    account: Account
}

type createArticlePayload {
    article: Article
}

type createAssessmentQuestionnairePayload {
    assessmentQuestionnaire: AssessmentQuestionnaire
}

type createBookPayload {
    book: Book
}

type createCategoryPayload {
    category: Category
}

type createClassificationPayload {
    classification: Classification
}

type createColorPayload {
    color: Color
}

type createCoursePayload {
    course: Course
}

type createCreditCardPayload {
    creditCard: CreditCard
}

type createCurrencyPayload {
    currency: PaymentCurrency
}

type createEhrPayload {
    ehr: Ehr
}

type createEventPayload {
    event: Event
}

type createExercisePayload {
    exercise: Exercise
}

type createGamePayload {
    game: Game
}

type createLocationPayload {
    location: Location
}

type createOrderPayload {
    order: PaymentOrder
}

type createOrganizationUnitPayload {
    organizationUnit: UsersOrganizationunitsOrganizationUnit
}

type createParentingPayload {
    parenting: Parenting
}

type createPatientPayload {
    patient: Patient
}

type createPaymentMethodPayload {
    paymentMethod: PaymentMethod
}

type createPlanPayload {
    plan: Plan
}

type createPostPayload {
    post: Post
}

type createProviderPayload {
    provider: Provider
}

type createQuestionnaireAnswerPayload {
    questionnaireAnswer: QuestionnaireAnswer
}

type createQuestionnairePayload {
    questionnaire: Questionnaire
}

type createReminderPayload {
    reminder: Reminder
}

type createRolePayload {
    role: UsersPermissionsRole
}

type createSchoolPayload {
    school: School
}

type createSupplementPayload {
    supplement: Supplement
}

type createTelemetryPayload {
    telemetry: Telemetry
}

type createTrademarkPayload {
    trademark: Trademark
}

type createUserAddressPayload {
    userAddress: UserAddress
}

type createUserAgreementPayload {
    userAgreement: UserAgreement
}

type createUserAssessmentPayload {
    userAssessment: UserAssessment
}

type createUserExercisePayload {
    userExercise: UserExercise
}

type createUserParentingPayload {
    userParenting: UserParenting
}

type createUserPayload {
    user: UsersPermissionsUser
}

type createUserPlanPayload {
    userPlan: UserPlan
}

type createVenuePayload {
    venue: Venue
}

type createWebinarPayload {
    webinar: Webinar
}

type deleteAboutFastBraiinPayload {
    aboutFastBraiin: AboutFastBraiin
}

type deleteAccountPayload {
    account: Account
}

type deleteAppTermOfServicePayload {
    appTermOfService: AppTermOfService
}

type deleteArticlePayload {
    article: Article
}

type deleteAssessmentQuestionnairePayload {
    assessmentQuestionnaire: AssessmentQuestionnaire
}

type deleteAssessmentTermOfServicePayload {
    assessmentTermOfService: AssessmentTermOfService
}

type deleteBookPayload {
    book: Book
}

type deleteCategoryPayload {
    category: Category
}

type deleteClassificationPayload {
    classification: Classification
}

type deleteColorPayload {
    color: Color
}

type deleteCoursePayload {
    course: Course
}

type deleteCreditCardPayload {
    creditCard: CreditCard
}

type deleteCurrencyPayload {
    currency: PaymentCurrency
}

type deleteEhrPayload {
    ehr: Ehr
}

type deleteEventPayload {
    event: Event
}

type deleteExercisePayload {
    exercise: Exercise
}

type deleteFilePayload {
    file: UploadFile
}

type deleteGamePayload {
    game: Game
}

type deleteLocationPayload {
    location: Location
}

type deleteOrderPayload {
    order: PaymentOrder
}

type deleteOrganizationUnitPayload {
    organizationUnit: UsersOrganizationunitsOrganizationUnit
}

type deleteParentingPayload {
    parenting: Parenting
}

type deletePatientPayload {
    patient: Patient
}

type deletePaymentMethodPayload {
    paymentMethod: PaymentMethod
}

type deletePaymentPolicyPayload {
    paymentPolicy: PaymentPolicy
}

type deletePlanPayload {
    plan: Plan
}

type deletePostPayload {
    post: Post
}

type deleteProviderPayload {
    provider: Provider
}

type deleteQuestionnaireAnswerPayload {
    questionnaireAnswer: QuestionnaireAnswer
}

type deleteQuestionnairePayload {
    questionnaire: Questionnaire
}

type deleteReminderPayload {
    reminder: Reminder
}

type deleteRolePayload {
    role: UsersPermissionsRole
}

type deleteSchoolPayload {
    school: School
}

type deleteSupplementPayload {
    supplement: Supplement
}

type deleteTelemetryPayload {
    telemetry: Telemetry
}

type deleteTrademarkPayload {
    trademark: Trademark
}

type deleteUserAddressPayload {
    userAddress: UserAddress
}

type deleteUserAgreementPayload {
    userAgreement: UserAgreement
}

type deleteUserAssessmentPayload {
    userAssessment: UserAssessment
}

type deleteUserExercisePayload {
    userExercise: UserExercise
}

type deleteUserParentingPayload {
    userParenting: UserParenting
}

type deleteUserPayload {
    user: UsersPermissionsUser
}

type deleteUserPlanPayload {
    userPlan: UserPlan
}

type deleteVenuePayload {
    venue: Venue
}

type deleteVersionPayload {
    version: Version
}

type deleteWebinarPayload {
    webinar: Webinar
}

type requestOrderPayPayload {
    order: PaymentOrder
    ret: JSON
}

type updateAboutFastBraiinPayload {
    aboutFastBraiin: AboutFastBraiin
}

type updateAccountPayload {
    account: Account
}

type updateAppTermOfServicePayload {
    appTermOfService: AppTermOfService
}

type updateArticlePayload {
    article: Article
}

type updateAssessmentQuestionnairePayload {
    assessmentQuestionnaire: AssessmentQuestionnaire
}

type updateAssessmentTermOfServicePayload {
    assessmentTermOfService: AssessmentTermOfService
}

type updateBookPayload {
    book: Book
}

type updateCategoryPayload {
    category: Category
}

type updateClassificationPayload {
    classification: Classification
}

type updateColorPayload {
    color: Color
}

type updateCoursePayload {
    course: Course
}

type updateCreditCardPayload {
    creditCard: CreditCard
}

type updateCurrencyPayload {
    currency: PaymentCurrency
}

type updateEhrPayload {
    ehr: Ehr
}

type updateEventPayload {
    event: Event
}

type updateExercisePayload {
    exercise: Exercise
}

type updateGamePayload {
    game: Game
}

type updateLocationPayload {
    location: Location
}

type updateOrderPayload {
    order: PaymentOrder
}

type updateOrganizationUnitPayload {
    organizationUnit: UsersOrganizationunitsOrganizationUnit
}

type updateParentingPayload {
    parenting: Parenting
}

type updatePatientPayload {
    patient: Patient
}

type updatePaymentMethodPayload {
    paymentMethod: PaymentMethod
}

type updatePaymentPolicyPayload {
    paymentPolicy: PaymentPolicy
}

type updatePlanPayload {
    plan: Plan
}

type updatePostPayload {
    post: Post
}

type updateProviderPayload {
    provider: Provider
}

type updateQuestionnaireAnswerPayload {
    questionnaireAnswer: QuestionnaireAnswer
}

type updateQuestionnairePayload {
    questionnaire: Questionnaire
}

type updateReminderPayload {
    reminder: Reminder
}

type updateRolePayload {
    role: UsersPermissionsRole
}

type updateSchoolPayload {
    school: School
}

type updateSupplementPayload {
    supplement: Supplement
}

type updateTelemetryPayload {
    telemetry: Telemetry
}

type updateTrademarkPayload {
    trademark: Trademark
}

type updateUserAddressPayload {
    userAddress: UserAddress
}

type updateUserAgreementPayload {
    userAgreement: UserAgreement
}

type updateUserAssessmentPayload {
    userAssessment: UserAssessment
}

type updateUserExercisePayload {
    userExercise: UserExercise
}

type updateUserParentingPayload {
    userParenting: UserParenting
}

type updateUserPayload {
    user: UsersPermissionsUser
}

type updateUserPlanPayload {
    userPlan: UserPlan
}

type updateVenuePayload {
    venue: Venue
}

type updateVersionPayload {
    version: Version
}

type updateWebinarPayload {
    webinar: Webinar
}

enum BookType {
    online
    printed
}

enum CategoryType {
    app
    subject
}

enum ContentType {
    Private
    Public
}

enum DoctorSubject {
    Family
    Pediatrician
    Psychiatrist
    Psychologist
    other
}

enum EhrStatus {
    closed
    inProgress
    open
}

enum EhrSubject {
    ADHD
    cpt
    grade
    health
    math
    memory
    music
    nutrition
    parenting
    sleep
    social_skill
    spelling
}

enum EhrType {
    assessment
    clinic
    education
    exercise
    medicine
    nutrition
    sleep
    supplement
}

enum ExerciseType {
    home
    online
    school
    site
}

enum ForType {
    adult
    all
    child
}

enum GameType {
    appOnline
}

enum LocationType {
    clinic
    school
}

enum OrderStatusType {
    Closed
    Paid
    Refunded
    Refunding
    Removed
    RequestRefund
    Unpaied
}

enum PatientStatus {
    active
    registered
    removed
}

enum PlanStatus {
    canceled
    closed
    open
    started
    suspended
}

enum PostStatus {
    hidden
    published
    removed
}

enum PosterStatus {
    hidden
    published
    removed
}

enum PublicationState {
    LIVE
    PREVIEW
}

enum RelationType {
    father
    grandparent
    mother
    other
    sibling
}

enum ReminderType {
    daily
    normal
    scheduled
    weekly
}

enum SchoolType {
    highSchool
    k_12
    k_9
    kindergarten
    middleSchool
}

enum SexType {
    female
    male
    other
}

enum SummarySubject {
    cpt
}

enum SummaryType {
    measurable
}

enum TermOfServiceType {
    App
    Assessment
    Payment
}

enum UserStatus {
    active
    inactive
    removed
}

input AboutFastBraiinInput {
    content: String!
    created_by: ID
    updated_by: ID
}

input AccountInput {
    created_by: ID
    name: String!
    orders: [ID]
    updated_by: ID
    user: ID
}

input AppTermOfServiceInput {
    created_by: ID
    term_of_service: String
    updated_by: ID
}

input ArticleInput {
    content: String!
    created_by: ID
    episodes: [ComponentContentEpisodeInput]
    forPerson: ComponentDataForInput
    media: [ID]
    name: String
    order_items: [ID]
    post: ComponentContentPostInput!
    published_at: DateTime
    questionnaire: ID
    subject: ComponentDataEhrSubjectInput
    updated_by: ID
}

input AssessmentQuestionnaireInput {
    content: String!
    created_by: ID
    forPerson: ComponentDataForInput
    game: ID
    level: Int
    media: [ID]
    name: String!
    period_length: Int
    post: ComponentContentPostInput!
    product: ComponentContentProductInput
    questionnaire: ID
    questionnaireOnly: Boolean
    subject: ComponentDataEhrSubjectInput
    updated_by: ID
}

input AssessmentTermOfServiceInput {
    created_by: ID
    term_of_service: String
    updated_by: ID
}

input BookInput {
    content: String!
    created_by: ID
    episodes: [ComponentContentEpisodeInput]
    name: String!
    post: ComponentContentPostInput!
    product: ComponentContentProductInput
    type: BookType
    updated_by: ID
}

input CategoryInput {
    created_by: ID
    name: String!
    preserved: Boolean
    type: CategoryType
    updated_by: ID
}

input ClassificationInput {
    created_by: ID
    name: String
    published_at: DateTime
    sortIndex: Int
    updated_by: ID
}

input ColorInput {
    color: String
    created_by: ID
    updated_by: ID
}

input ComponentContentEpisodeInput {
    content: String
    subtitle: String
    title: String
}

input ComponentContentEventComponentInput {
    contacts: String
    dateTime: DateTime!
    email: String
    eventPrices: [ComponentContentEventPriceInput]
    eventVenue: ID
    host: String
    meetingId: String
    phoneNumber: String
}

input ComponentContentEventPriceInput {
    currency: ID
    name: String
    prePrice: Float
    price: Float!
}

input ComponentContentPostInput {
    author: ID
    categories: [ID]
    cover_background_color: ID
    currency: ID
    image: [ID]
    needShipping: Boolean
    prePrice: Float
    price: Float
    rating: Int
    recommended: Boolean
    status: PostStatus
    subtitle: String
    title: String!
    trademark: ID
    updated_day: Date!
    vipText: String
    vip_color: ID
}

input ComponentContentProductInput {
    content: String
    currency: ID
    inventory: Int
    name: String
    preUnitPrice: Float
    provider: ID
    shipping: Boolean
    unitPrice: Float
}

input ComponentContentSummaryInput {
    rating: Int
    subject: SummarySubject!
    type: SummaryType!
}

input ComponentDataAddressInput {
    address1: String
    address2: String
    address3: String
    city: String
    country: String
    fullName: String
    postalCode: String
    state: String
}

input ComponentDataEhrSubjectInput {
    type: EhrSubject
}

input ComponentDataEhrTypeInput {
    type: EhrType
}

input ComponentDataForInput {
    type: ForType
}

input ComponentDataPositionInput {
    altitude: Float
    head: Float
    latitude: Float
    longitude: Float
    speed: Float
    timestamp: DateTime
}

input ComponentUserAuthorInput {
    foo: String
}

input ComponentUserChildInput {
    relationToUser: RelationType!
    schools: [ID]
    teacher: ID
}

input ComponentUserCounselorInput {
    location: ID
    patients: [ID]
}

input ComponentUserDoctorInput {
    location: ID
    patients: [ID]
    subject: DoctorSubject!
}

input ComponentUserNurseInput {
    location: ID
    patients: [ID]
}

input ComponentUserParentInput {
    children: [ID]
}

input ComponentUserPatientInput {
    counselor: ID
    doctor: ID
    nurse: ID
}

input ComponentUserTeacherInput {
    atSchool: ID
    children: [ID]
    role: String
    school: String
}

input CourseInput {
    content: String
    contentType: ContentType
    created_by: ID
    medias: [ID]
    picture: ID
    subtitle: String
    title: String
    updated_by: ID
}

input CreditCardInput {
    address: ID
    created_by: ID
    cvc: String!
    expMonth: Int!
    expYear: Int!
    name: String!
    number: String!
    updated_by: ID
    user: ID
}

input CurrencyInput {
    code: String
    created_by: ID
    decimal_digits: Int!
    name: String!
    name_plural: String
    rounding: Int
    symbol: String
    symbol_native: String
    updated_by: ID
}

input EhrInput {
    classification: ID
    created_by: ID
    medias: [ID]
    office_comments: String
    patient: ID
    position: ComponentDataPositionInput
    questionnaire_answer: ID
    record: JSON
    source: String!
    source_id: String!
    status: EhrStatus
    subject: ComponentDataEhrSubjectInput!
    summaries: [ComponentContentSummaryInput]
    updated_by: ID
}

input EventInput {
    content: String
    created_by: ID
    dicount: Float
    eventComponent: ComponentContentEventComponentInput!
    name: String!
    post: ComponentContentPostInput!
    updated_by: ID
}

input ExerciseInput {
    age: Int
    content: String!
    created_by: ID
    forPerson: ComponentDataForInput
    game: ID
    level: Int
    post: ComponentContentPostInput!
    questionnaire: ID
    subject: ComponentDataEhrSubjectInput
    type: ExerciseType
    updated_by: ID
}

input FileInfoInput {
    alternativeText: String
    caption: String
    name: String
}

input FileInput {
    alternativeText: String
    caption: String
    created_by: ID
    ext: String
    formats: JSON
    hash: String!
    height: Int
    mime: String!
    name: String!
    previewUrl: String
    provider: String!
    provider_metadata: JSON
    related: [ID]
    size: Float!
    updated_by: ID
    url: String!
    width: Int
}

input GameInput {
    content: String
    cptLevel: Int
    created_by: ID
    medias: [ID]
    name: String!
    provider: String
    trademark: ID
    type: GameType!
    updated_by: ID
}

input InputID {
    id: ID!
}

input LocationInput {
    address: String!
    content: String
    counselors: [ID]
    created_by: ID
    description: String
    doctors: [ID]
    email: String
    name: String!
    nurses: [ID]
    phone: String
    post: ComponentContentPostInput!
    qrCode: ID
    type: LocationType!
    updated_by: ID
    web: String
}

input MyAddressInput {
    address: ComponentDataAddressInput
    tag: String
}

input OrderInput {
    additional: JSON
    created_by: ID
    currency: ID
    description: String
    expire: DateTime
    extra: JSON
    items: [ID]
    needpayPrice: Float
    outTradeId: String
    outTradeProvider: String
    paiedPrice: Float
    price: Float
    shippingAddress: ComponentDataAddressInput
    status: OrderStatusType
    updated_by: ID
    user: ID
    uuid: String
}

input OrderItemInput {
    additional: JSON
    created_by: ID
    currency: ID
    extra: JSON
    name: String!
    order: ID
    picture: ID
    preUnitPrice: Float
    quantity: Int
    related: ID
    sourceId: String
    sourceType: String
    unitPrice: Float
    updated_by: ID
}

input OrganizationUnitInput {
    children: [ID]
    code: String
    created_by: ID
    displayName: String!
    parent: ID
    roles: [ID]
    updated_by: ID
    users: [ID]
}

input ParentingInput {
    content: String
    created_by: ID
    media: [ID]
    name: String!
    pdfFiles: ID
    post: ComponentContentPostInput!
    questionnaire: ID
    subject: ComponentDataEhrSubjectInput
    updated_by: ID
}

input PatientInput {
    counselor: ID
    created_by: ID
    doctor: ID
    ehrs: [ID]
    location: ID
    meetingId: String
    name: String!
    nurse: ID
    status: PatientStatus
    teacher: ID
    updated_by: ID
    user: ID
}

input PaymentMethodInput {
    billingAddress: ID
    created_by: ID
    creditCard: ID
    livemode: Boolean
    stripeId: String!
    type: String
    updated_by: ID
    user: ID
}

input PaymentPolicyInput {
    created_by: ID
    policy: String
    updated_by: ID
}

input PlanInput {
    articles: [ID]
    assessment: [ID]
    books: [ID]
    content: String
    created_by: ID
    exercises: [ID]
    forPerson: ComponentDataForInput
    name: String!
    parentings: [ID]
    post: ComponentContentPostInput!
    questionnaire: ID
    supplements: [ID]
    updated_by: ID
}

input PostInput {
    author: ID
    categories: [ID]
    cover_background_color: ID
    created_by: ID
    currency: ID
    entityRawId: String
    entityType: String
    image: [ID]
    needShipping: Boolean
    prePrice: Float
    price: Float
    published_at: DateTime
    rating: Int
    rawPostId: Int
    recommended: Boolean
    status: PosterStatus
    subtitle: String
    title: String!
    trademark: ID
    updated_by: ID
    updated_day: Date
    vipText: String
    vip_color: ID
}

input ProviderInput {
    address: String
    content: String
    created_by: ID
    email: String
    name: String
    phoneNumber: String
    trademark: ID
    updated_by: ID
}

input QuestionnaireAnswerInput {
    created_by: ID
    data: JSON
    name: String!
    questionnaire: ID
    submitted: Boolean
    updated_by: ID
    user: ID
}

input QuestionnaireInput {
    assessment_questionnaires: [ID]
    created_by: ID
    data: String
    displayName: String
    name: String!
    provider: String
    updated_by: ID
}

input ReminderInput {
    body: String
    created_by: ID
    dateTime: DateTime
    name: String!
    related: [ID]
    source: String
    sourceId: String
    type: ReminderType
    updated_by: ID
    user: ID
}

input RoleInput {
    created_by: ID
    description: String
    name: String!
    permissions: [ID]
    type: String
    updated_by: ID
    users: [ID]
}

input SchoolInput {
    address: String
    created_by: ID
    email: String
    name: String!
    phone: String
    picture: ID
    teachers: [ID]
    type: SchoolType!
    updated_by: ID
}

input SettingInput {
    created_by: ID
    data: JSON
    updated_by: ID
    user: ID
}

input SupplementInput {
    content: String
    created_by: ID
    forPerson: ComponentDataForInput
    name: String!
    post: ComponentContentPostInput!
    product: ComponentContentProductInput
    subject: ComponentDataEhrSubjectInput
    updated_by: ID
}

input TelemetryInput {
    created_by: ID
    raw: JSON
    updated_by: ID
}

input TestInput {
    chart: String
    created_by: ID
    updated_by: ID
}

input TrademarkInput {
    created_by: ID
    image: ID
    name: String!
    updated_by: ID
}

input UserAddressInput {
    address: ComponentDataAddressInput
    created_by: ID
    tag: String
    updated_by: ID
    user: ID
}

input UserAgreementInput {
    content: String!
    created_by: ID
    lastVersionDate: DateTime!
    termOfServiceType: TermOfServiceType!
    updated_by: ID
    user: ID
    value: Boolean
}

input UserAssessmentInput {
    assessment_questionnaire: ID
    created_by: ID
    updated_by: ID
    user: ID
}

input UserExerciseInput {
    created_by: ID
    exercise: ID
    updated_by: ID
    user: ID
}

input UserInput {
    accountInfo: ID
    authorInfo: ComponentUserAuthorInput
    birthday: Date
    blocked: Boolean
    childInfo: ComponentUserChildInput
    children: [ID]
    confirmationToken: String
    confirmed: Boolean
    content: String
    counselorInfo: ComponentUserCounselorInput
    created_by: ID
    doctorInfo: ComponentUserDoctorInput
    email: String
    fullName: String
    image: ID
    name: String
    nurseInfo: ComponentUserNurseInput
    organization_units: [ID]
    parent: ID
    parentInfo: ComponentUserParentInput
    password: String
    patientInfo: ID
    phone: String
    provider: String
    qrUrl: String
    resetPasswordToken: String
    role: ID
    second_email: String
    sex: SexType
    status: UserStatus
    teacherInfo: ComponentUserTeacherInput
    updated_by: ID
    user_agreements: [ID]
    username: String!
}

input UserParentingInput {
    created_by: ID
    parenting: ID
    updated_by: ID
    user: ID
}

input UserPlanInput {
    created_by: ID
    parentings: [ID]
    status: PlanStatus
    updated_by: ID
    user: ID
    user_assessments: [ID]
    user_exercises: [ID]
}

input UsersPermissionsLoginInput {
    identifier: String!
    password: String!
    provider: String = "local"
}

input UsersPermissionsRegisterInput {
    email: String!
    password: String!
    username: String!
}

input VenueInput {
    address: String
    capacity: Int
    contacts: String
    content: String
    created_by: ID
    email: String
    name: String
    phoneNumber: String
    picture: ID
    post: ComponentContentPostInput
    updated_by: ID
}

input VersionInput {
    created_by: ID
    description: String!
    number: String
    updated_by: ID
}

input WebinarInput {
    content: String
    created_by: ID
    meetingId: String
    post: ComponentContentPostInput
    schedule: DateTime
    subject: ComponentDataEhrSubjectInput
    updated_by: ID
}

input agreeTermOfServiceInput {
    content: String!
    lastVersionDate: DateTime!
    termOfServiceType: TermOfServiceType!
}

input batchTelemetryInput {
    data: [TelemetryInput]
}

input cancelOrderInput {
    where: InputID
}

input childInput {
    birthday: Date!
    childInfo: ComponentUserChildInput!
    fullName: String!
    image: ID
    name: String
    parent: ID!
    phone: String!
    sex: SexType!
}

input createAccountInput {
    data: AccountInput
}

input createArticleInput {
    data: ArticleInput
}

input createAssessmentQuestionnaireInput {
    data: AssessmentQuestionnaireInput
}

input createBookInput {
    data: BookInput
}

input createCategoryInput {
    data: CategoryInput
}

input createChildInput {
    data: childInput
}

input createClassificationInput {
    data: ClassificationInput
}

input createColorInput {
    data: ColorInput
}

input createCourseInput {
    data: CourseInput
}

input createCreditCardInput {
    data: CreditCardInput
}

input createCurrencyInput {
    data: CurrencyInput
}

input createEhrInput {
    data: EhrInput
}

input createEventInput {
    data: EventInput
}

input createExerciseInput {
    data: ExerciseInput
}

input createGameInput {
    data: GameInput
}

input createLocationInput {
    data: LocationInput
}

input createMyAddressInput {
    data: MyAddressInput
}

input createMyOrderInput {
    data: myOrderInput
}

input createOrderInput {
    data: OrderInput
}

input createOrganizationUnitInput {
    data: OrganizationUnitInput
}

input createParentingInput {
    data: ParentingInput
}

input createPatientInput {
    data: PatientInput
}

input createPaymentMethodInput {
    data: PaymentMethodInput
}

input createPlanInput {
    data: PlanInput
}

input createPostInput {
    data: PostInput
}

input createProviderInput {
    data: ProviderInput
}

input createQuestionnaireAnswerInput {
    data: QuestionnaireAnswerInput
}

input createQuestionnaireInput {
    data: QuestionnaireInput
}

input createReminderInput {
    data: ReminderInput
}

input createRoleInput {
    data: RoleInput
}

input createSchoolInput {
    data: SchoolInput
}

input createSupplementInput {
    data: SupplementInput
}

input createTelemetryInput {
    data: TelemetryInput
}

input createTrademarkInput {
    data: TrademarkInput
}

input createUnifiedOrderInput {
    data: unifiedOrderInput
}

input createUserAddressInput {
    data: UserAddressInput
}

input createUserAgreementInput {
    data: UserAgreementInput
}

input createUserAssessmentInput {
    data: UserAssessmentInput
}

input createUserExerciseInput {
    data: UserExerciseInput
}

input createUserInput {
    data: UserInput
}

input createUserParentingInput {
    data: UserParentingInput
}

input createUserPlanInput {
    data: UserPlanInput
}

input createVenueInput {
    data: VenueInput
}

input createWebinarInput {
    data: WebinarInput
}

input deleteAccountInput {
    where: InputID
}

input deleteArticleInput {
    where: InputID
}

input deleteAssessmentQuestionnaireInput {
    where: InputID
}

input deleteBookInput {
    where: InputID
}

input deleteCategoryInput {
    where: InputID
}

input deleteClassificationInput {
    where: InputID
}

input deleteColorInput {
    where: InputID
}

input deleteCourseInput {
    where: InputID
}

input deleteCreditCardInput {
    where: InputID
}

input deleteCurrencyInput {
    where: InputID
}

input deleteEhrInput {
    where: InputID
}

input deleteEventInput {
    where: InputID
}

input deleteExerciseInput {
    where: InputID
}

input deleteFileInput {
    where: InputID
}

input deleteGameInput {
    where: InputID
}

input deleteLocationInput {
    where: InputID
}

input deleteOrderInput {
    where: InputID
}

input deleteOrganizationUnitInput {
    where: InputID
}

input deleteParentingInput {
    where: InputID
}

input deletePatientInput {
    where: InputID
}

input deletePaymentMethodInput {
    where: InputID
}

input deletePlanInput {
    where: InputID
}

input deletePostInput {
    where: InputID
}

input deleteProviderInput {
    where: InputID
}

input deleteQuestionnaireAnswerInput {
    where: InputID
}

input deleteQuestionnaireInput {
    where: InputID
}

input deleteReminderInput {
    where: InputID
}

input deleteRoleInput {
    where: InputID
}

input deleteSchoolInput {
    where: InputID
}

input deleteSupplementInput {
    where: InputID
}

input deleteTelemetryInput {
    where: InputID
}

input deleteTrademarkInput {
    where: InputID
}

input deleteUserAddressInput {
    where: InputID
}

input deleteUserAgreementInput {
    where: InputID
}

input deleteUserAssessmentInput {
    where: InputID
}

input deleteUserExerciseInput {
    where: InputID
}

input deleteUserInput {
    where: InputID
}

input deleteUserParentingInput {
    where: InputID
}

input deleteUserPlanInput {
    where: InputID
}

input deleteVenueInput {
    where: InputID
}

input deleteWebinarInput {
    where: InputID
}

input editAboutFastBraiinInput {
    content: String
    created_by: ID
    updated_by: ID
}

input editAccountInput {
    created_by: ID
    name: String
    orders: [ID]
    updated_by: ID
    user: ID
}

input editAppTermOfServiceInput {
    created_by: ID
    term_of_service: String
    updated_by: ID
}

input editArticleInput {
    content: String
    created_by: ID
    episodes: [editComponentContentEpisodeInput]
    forPerson: editComponentDataForInput
    media: [ID]
    name: String
    order_items: [ID]
    post: editComponentContentPostInput
    published_at: DateTime
    questionnaire: ID
    subject: editComponentDataEhrSubjectInput
    updated_by: ID
}

input editAssessmentQuestionnaireInput {
    content: String
    created_by: ID
    forPerson: editComponentDataForInput
    game: ID
    level: Int
    media: [ID]
    name: String
    period_length: Int
    post: editComponentContentPostInput
    product: editComponentContentProductInput
    questionnaire: ID
    questionnaireOnly: Boolean
    subject: editComponentDataEhrSubjectInput
    updated_by: ID
}

input editAssessmentTermOfServiceInput {
    created_by: ID
    term_of_service: String
    updated_by: ID
}

input editBookInput {
    content: String
    created_by: ID
    episodes: [editComponentContentEpisodeInput]
    name: String
    post: editComponentContentPostInput
    product: editComponentContentProductInput
    type: BookType
    updated_by: ID
}

input editCategoryInput {
    created_by: ID
    name: String
    preserved: Boolean
    type: CategoryType
    updated_by: ID
}

input editChildInput {
    birthday: Date
    childInfo: ComponentUserChildInput
    fullName: String
    image: ID
    name: String
    phone: String
    sex: SexType
}

input editClassificationInput {
    created_by: ID
    name: String
    published_at: DateTime
    sortIndex: Int
    updated_by: ID
}

input editColorInput {
    color: String
    created_by: ID
    updated_by: ID
}

input editComponentContentEpisodeInput {
    content: String
    id: ID
    subtitle: String
    title: String
}

input editComponentContentEventComponentInput {
    contacts: String
    dateTime: DateTime
    email: String
    eventPrices: [editComponentContentEventPriceInput]
    eventVenue: ID
    host: String
    id: ID
    meetingId: String
    phoneNumber: String
}

input editComponentContentEventPriceInput {
    currency: ID
    id: ID
    name: String
    prePrice: Float
    price: Float
}

input editComponentContentPostInput {
    author: ID
    categories: [ID]
    cover_background_color: ID
    currency: ID
    id: ID
    image: [ID]
    needShipping: Boolean
    prePrice: Float
    price: Float
    rating: Int
    recommended: Boolean
    status: PostStatus
    subtitle: String
    title: String
    trademark: ID
    updated_day: Date
    vipText: String
    vip_color: ID
}

input editComponentContentProductInput {
    content: String
    currency: ID
    id: ID
    inventory: Int
    name: String
    preUnitPrice: Float
    provider: ID
    shipping: Boolean
    unitPrice: Float
}

input editComponentContentSummaryInput {
    id: ID
    rating: Int
    subject: SummarySubject
    type: SummaryType
}

input editComponentDataAddressInput {
    address1: String
    address2: String
    address3: String
    city: String
    country: String
    fullName: String
    id: ID
    postalCode: String
    state: String
}

input editComponentDataEhrSubjectInput {
    id: ID
    type: EhrSubject
}

input editComponentDataEhrTypeInput {
    id: ID
    type: EhrType
}

input editComponentDataForInput {
    id: ID
    type: ForType
}

input editComponentDataPositionInput {
    altitude: Float
    head: Float
    id: ID
    latitude: Float
    longitude: Float
    speed: Float
    timestamp: DateTime
}

input editComponentUserAuthorInput {
    foo: String
    id: ID
}

input editComponentUserChildInput {
    id: ID
    relationToUser: RelationType
    schools: [ID]
    teacher: ID
}

input editComponentUserCounselorInput {
    id: ID
    location: ID
    patients: [ID]
}

input editComponentUserDoctorInput {
    id: ID
    location: ID
    patients: [ID]
    subject: DoctorSubject
}

input editComponentUserNurseInput {
    id: ID
    location: ID
    patients: [ID]
}

input editComponentUserParentInput {
    children: [ID]
    id: ID
}

input editComponentUserPatientInput {
    counselor: ID
    doctor: ID
    id: ID
    nurse: ID
}

input editComponentUserTeacherInput {
    atSchool: ID
    children: [ID]
    id: ID
    role: String
    school: String
}

input editCourseInput {
    content: String
    contentType: ContentType
    created_by: ID
    medias: [ID]
    picture: ID
    subtitle: String
    title: String
    updated_by: ID
}

input editCreditCardInput {
    address: ID
    created_by: ID
    cvc: String
    expMonth: Int
    expYear: Int
    name: String
    number: String
    updated_by: ID
    user: ID
}

input editCurrencyInput {
    code: String
    created_by: ID
    decimal_digits: Int
    name: String
    name_plural: String
    rounding: Int
    symbol: String
    symbol_native: String
    updated_by: ID
}

input editEhrInput {
    classification: ID
    created_by: ID
    medias: [ID]
    office_comments: String
    patient: ID
    position: editComponentDataPositionInput
    questionnaire_answer: ID
    record: JSON
    source: String
    source_id: String
    status: EhrStatus
    subject: editComponentDataEhrSubjectInput
    summaries: [editComponentContentSummaryInput]
    updated_by: ID
}

input editEventInput {
    content: String
    created_by: ID
    dicount: Float
    eventComponent: editComponentContentEventComponentInput
    name: String
    post: editComponentContentPostInput
    updated_by: ID
}

input editExerciseInput {
    age: Int
    content: String
    created_by: ID
    forPerson: editComponentDataForInput
    game: ID
    level: Int
    post: editComponentContentPostInput
    questionnaire: ID
    subject: editComponentDataEhrSubjectInput
    type: ExerciseType
    updated_by: ID
}

input editFileInput {
    alternativeText: String
    caption: String
    created_by: ID
    ext: String
    formats: JSON
    hash: String
    height: Int
    mime: String
    name: String
    previewUrl: String
    provider: String
    provider_metadata: JSON
    related: [ID]
    size: Float
    updated_by: ID
    url: String
    width: Int
}

input editGameInput {
    content: String
    cptLevel: Int
    created_by: ID
    medias: [ID]
    name: String
    provider: String
    trademark: ID
    type: GameType
    updated_by: ID
}

input editLocationInput {
    address: String
    content: String
    counselors: [ID]
    created_by: ID
    description: String
    doctors: [ID]
    email: String
    name: String
    nurses: [ID]
    phone: String
    post: editComponentContentPostInput
    qrCode: ID
    type: LocationType
    updated_by: ID
    web: String
}

input editMyAddressInput {
    address: ComponentDataAddressInput
    tag: String
}

input editOrderInput {
    additional: JSON
    created_by: ID
    currency: ID
    description: String
    expire: DateTime
    extra: JSON
    items: [ID]
    needpayPrice: Float
    outTradeId: String
    outTradeProvider: String
    paiedPrice: Float
    price: Float
    shippingAddress: editComponentDataAddressInput
    status: OrderStatusType
    updated_by: ID
    user: ID
    uuid: String
}

input editOrderItemInput {
    additional: JSON
    created_by: ID
    currency: ID
    extra: JSON
    name: String
    order: ID
    picture: ID
    preUnitPrice: Float
    quantity: Int
    related: ID
    sourceId: String
    sourceType: String
    unitPrice: Float
    updated_by: ID
}

input editOrganizationUnitInput {
    children: [ID]
    code: String
    created_by: ID
    displayName: String
    parent: ID
    roles: [ID]
    updated_by: ID
    users: [ID]
}

input editParentingInput {
    content: String
    created_by: ID
    media: [ID]
    name: String
    pdfFiles: ID
    post: editComponentContentPostInput
    questionnaire: ID
    subject: editComponentDataEhrSubjectInput
    updated_by: ID
}

input editPatientInput {
    counselor: ID
    created_by: ID
    doctor: ID
    ehrs: [ID]
    location: ID
    meetingId: String
    name: String
    nurse: ID
    status: PatientStatus
    teacher: ID
    updated_by: ID
    user: ID
}

input editPaymentMethodInput {
    billingAddress: ID
    created_by: ID
    creditCard: ID
    livemode: Boolean
    stripeId: String
    type: String
    updated_by: ID
    user: ID
}

input editPaymentPolicyInput {
    created_by: ID
    policy: String
    updated_by: ID
}

input editPlanInput {
    articles: [ID]
    assessment: [ID]
    books: [ID]
    content: String
    created_by: ID
    exercises: [ID]
    forPerson: editComponentDataForInput
    name: String
    parentings: [ID]
    post: editComponentContentPostInput
    questionnaire: ID
    supplements: [ID]
    updated_by: ID
}

input editPostInput {
    author: ID
    categories: [ID]
    cover_background_color: ID
    created_by: ID
    currency: ID
    entityRawId: String
    entityType: String
    image: [ID]
    needShipping: Boolean
    prePrice: Float
    price: Float
    published_at: DateTime
    rating: Int
    rawPostId: Int
    recommended: Boolean
    status: PosterStatus
    subtitle: String
    title: String
    trademark: ID
    updated_by: ID
    updated_day: Date
    vipText: String
    vip_color: ID
}

input editProviderInput {
    address: String
    content: String
    created_by: ID
    email: String
    name: String
    phoneNumber: String
    trademark: ID
    updated_by: ID
}

input editQuestionnaireAnswerInput {
    created_by: ID
    data: JSON
    name: String
    questionnaire: ID
    submitted: Boolean
    updated_by: ID
    user: ID
}

input editQuestionnaireInput {
    assessment_questionnaires: [ID]
    created_by: ID
    data: String
    displayName: String
    name: String
    provider: String
    updated_by: ID
}

input editReminderInput {
    body: String
    created_by: ID
    dateTime: DateTime
    name: String
    related: [ID]
    source: String
    sourceId: String
    type: ReminderType
    updated_by: ID
    user: ID
}

input editRoleInput {
    created_by: ID
    description: String
    name: String
    permissions: [ID]
    type: String
    updated_by: ID
    users: [ID]
}

input editSchoolInput {
    address: String
    created_by: ID
    email: String
    name: String
    phone: String
    picture: ID
    teachers: [ID]
    type: SchoolType
    updated_by: ID
}

input editSettingInput {
    created_by: ID
    data: JSON
    updated_by: ID
    user: ID
}

input editSupplementInput {
    content: String
    created_by: ID
    forPerson: editComponentDataForInput
    name: String
    post: editComponentContentPostInput
    product: editComponentContentProductInput
    subject: editComponentDataEhrSubjectInput
    updated_by: ID
}

input editTelemetryInput {
    created_by: ID
    raw: JSON
    updated_by: ID
}

input editTestInput {
    chart: String
    created_by: ID
    updated_by: ID
}

input editTrademarkInput {
    created_by: ID
    image: ID
    name: String
    updated_by: ID
}

input editUserAddressInput {
    address: editComponentDataAddressInput
    created_by: ID
    tag: String
    updated_by: ID
    user: ID
}

input editUserAgreementInput {
    content: String
    created_by: ID
    lastVersionDate: DateTime
    termOfServiceType: TermOfServiceType
    updated_by: ID
    user: ID
    value: Boolean
}

input editUserAssessmentInput {
    assessment_questionnaire: ID
    created_by: ID
    updated_by: ID
    user: ID
}

input editUserExerciseInput {
    created_by: ID
    exercise: ID
    updated_by: ID
    user: ID
}

input editUserInput {
    accountInfo: ID
    authorInfo: editComponentUserAuthorInput
    birthday: Date
    blocked: Boolean
    childInfo: editComponentUserChildInput
    children: [ID]
    confirmationToken: String
    confirmed: Boolean
    content: String
    counselorInfo: editComponentUserCounselorInput
    created_by: ID
    doctorInfo: editComponentUserDoctorInput
    email: String
    fullName: String
    image: ID
    name: String
    nurseInfo: editComponentUserNurseInput
    organization_units: [ID]
    parent: ID
    parentInfo: editComponentUserParentInput
    password: String
    patientInfo: ID
    phone: String
    provider: String
    qrUrl: String
    resetPasswordToken: String
    role: ID
    second_email: String
    sex: SexType
    status: UserStatus
    teacherInfo: editComponentUserTeacherInput
    updated_by: ID
    user_agreements: [ID]
    username: String
}

input editUserParentingInput {
    created_by: ID
    parenting: ID
    updated_by: ID
    user: ID
}

input editUserPlanInput {
    created_by: ID
    parentings: [ID]
    status: PlanStatus
    updated_by: ID
    user: ID
    user_assessments: [ID]
    user_exercises: [ID]
}

input editVenueInput {
    address: String
    capacity: Int
    contacts: String
    content: String
    created_by: ID
    email: String
    name: String
    phoneNumber: String
    picture: ID
    post: editComponentContentPostInput
    updated_by: ID
}

input editVersionInput {
    created_by: ID
    description: String
    number: String
    updated_by: ID
}

input editWebinarInput {
    content: String
    created_by: ID
    meetingId: String
    post: editComponentContentPostInput
    schedule: DateTime
    subject: editComponentDataEhrSubjectInput
    updated_by: ID
}

input myOrderInput {
    additional: JSON
    currency: ID!
    description: String
    items: [orderItemInput]
    shippingAddress: ComponentDataAddressInput
}

input orderItemInput {
    additional: JSON
    name: String!
    picture: ID
    preUnitPrice: Float!
    quantity: Int!
    related: relatedInput
    sourceId: String
    sourceType: String
    unitPrice: Float!
}

input orderPayInput {
    options: JSON
    provider: String!
}

input relatedInput {
    field: String
    ref: String
    refId: String
    source: String
}

input requestOrderPayInput {
    data: orderPayInput
    where: InputID
}

input unifiedOrderInput {
    additional: JSON
    currency: ID!
    description: String
    items: [orderItemInput]
    shippingAddress: ComponentDataAddressInput
    user: ID
}

input updateAboutFastBraiinInput {
    data: editAboutFastBraiinInput
}

input updateAccountInput {
    data: editAccountInput
    where: InputID
}

input updateAppTermOfServiceInput {
    data: editAppTermOfServiceInput
}

input updateArticleInput {
    data: editArticleInput
    where: InputID
}

input updateAssessmentQuestionnaireInput {
    data: editAssessmentQuestionnaireInput
    where: InputID
}

input updateAssessmentTermOfServiceInput {
    data: editAssessmentTermOfServiceInput
}

input updateBookInput {
    data: editBookInput
    where: InputID
}

input updateCategoryInput {
    data: editCategoryInput
    where: InputID
}

input updateChildInput {
    data: editChildInput
    where: InputID
}

input updateClassificationInput {
    data: editClassificationInput
    where: InputID
}

input updateColorInput {
    data: editColorInput
    where: InputID
}

input updateCourseInput {
    data: editCourseInput
    where: InputID
}

input updateCreditCardInput {
    data: editCreditCardInput
    where: InputID
}

input updateCurrencyInput {
    data: editCurrencyInput
    where: InputID
}

input updateEhrInput {
    data: editEhrInput
    where: InputID
}

input updateEventInput {
    data: editEventInput
    where: InputID
}

input updateExerciseInput {
    data: editExerciseInput
    where: InputID
}

input updateGameInput {
    data: editGameInput
    where: InputID
}

input updateLocationInput {
    data: editLocationInput
    where: InputID
}

input updateMe {
    birthday: Date
    content: String
    email: String
    fullName: String
    image: ID
    name: String
    phone: String
    second_email: String
    sex: SexType
    username: String
}

input updateMeInput {
    data: updateMe
}

input updateMyAddressInput {
    data: editMyAddressInput
    where: InputID
}

input updateOrderInput {
    data: editOrderInput
    where: InputID
}

input updateOrganizationUnitInput {
    data: editOrganizationUnitInput
    where: InputID
}

input updateParentingInput {
    data: editParentingInput
    where: InputID
}

input updatePatientInput {
    data: editPatientInput
    where: InputID
}

input updatePaymentMethodInput {
    data: editPaymentMethodInput
    where: InputID
}

input updatePaymentPolicyInput {
    data: editPaymentPolicyInput
}

input updatePlanInput {
    data: editPlanInput
    where: InputID
}

input updatePostInput {
    data: editPostInput
    where: InputID
}

input updateProviderInput {
    data: editProviderInput
    where: InputID
}

input updateQuestionnaireAnswerInput {
    data: editQuestionnaireAnswerInput
    where: InputID
}

input updateQuestionnaireInput {
    data: editQuestionnaireInput
    where: InputID
}

input updateReminderInput {
    data: editReminderInput
    where: InputID
}

input updateRoleInput {
    data: editRoleInput
    where: InputID
}

input updateSchoolInput {
    data: editSchoolInput
    where: InputID
}

input updateSupplementInput {
    data: editSupplementInput
    where: InputID
}

input updateTelemetryInput {
    data: editTelemetryInput
    where: InputID
}

input updateTrademarkInput {
    data: editTrademarkInput
    where: InputID
}

input updateUserAddressInput {
    data: editUserAddressInput
    where: InputID
}

input updateUserAgreementInput {
    data: editUserAgreementInput
    where: InputID
}

input updateUserAssessmentInput {
    data: editUserAssessmentInput
    where: InputID
}

input updateUserExerciseInput {
    data: editUserExerciseInput
    where: InputID
}

input updateUserInput {
    data: editUserInput
    where: InputID
}

input updateUserParentingInput {
    data: editUserParentingInput
    where: InputID
}

input updateUserPlanInput {
    data: editUserPlanInput
    where: InputID
}

input updateVenueInput {
    data: editVenueInput
    where: InputID
}

input updateVersionInput {
    data: editVersionInput
}

input updateWebinarInput {
    data: editWebinarInput
    where: InputID
}


"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar DateTime

"A time string with format: HH:mm:ss.SSS"
scalar Time

"A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar Date

"The `Long` scalar type represents 52-bit integers"
scalar Long

"The `Upload` scalar type represents a file upload."
scalar Upload